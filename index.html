<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OJT Master - AI 기반 온보딩 교육 플랫폼</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Dexie.js (IndexedDB Wrapper for Local Cache) -->
  <script src="https://unpkg.com/dexie@4/dist/dexie.min.js"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
  <!-- Quill 2.0 Rich Text Editor -->
  <link href="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.snow.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.js"></script>
  <!-- Chart.js (Admin Dashboard) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    @keyframes spin { to { transform: rotate(360deg); } }
    .animate-spin { animation: spin 1s linear infinite; }
    /* Quill 에디터 스타일 커스터마이징 */
    .ql-container {
      font-size: 14px;
      min-height: 200px;
      border-bottom-left-radius: 0.5rem;
      border-bottom-right-radius: 0.5rem;
    }
    .ql-toolbar {
      border-top-left-radius: 0.5rem;
      border-top-right-radius: 0.5rem;
      background: #f8fafc;
    }
    .ql-editor {
      min-height: 180px;
    }
    .ql-editor.ql-blank::before {
      font-style: normal;
      color: #94a3b8;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, useRef } = React;

    // 간단한 아이콘 컴포넌트 (SVG 기반)
    const Icon = ({ name, className = "w-5 h-5" }) => {
      const icons = {
        brain: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" /></svg>,
        book: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" /></svg>,
        upload: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>,
        save: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" /></svg>,
        refresh: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>,
        x: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>,
        logout: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" /></svg>,
        user: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg>,
        trash: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
        server: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" /></svg>,
        alert: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>,
        settings: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
        check: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" /></svg>,
        play: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        link: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" /></svg>,
        file: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg>,
        globe: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9" /></svg>,
        text: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>,
        split: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" /></svg>,
        clock: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        layers: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>,
      };
      return icons[name] || null;
    };

    // =========================================
    // 설정 (Supabase)
    // =========================================
    const SUPABASE_URL = "https://cbvansmxutnogntbyswi.supabase.co";
    const SUPABASE_PUBLISHABLE_KEY = "sb_publishable_cPiRemnriBwn8rCT1JL9Qg_mjCeCBaI";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

    // =========================================
    // 설정 (Dexie.js - 로컬 캐시)
    // =========================================
    const CACHE_VERSION = 2; // 캐시 스키마 버전 (변경 시 증가)
    const CACHE_VERSION_KEY = 'ojt_cache_version';

    const localDb = new Dexie('OJTMasterCache');
    localDb.version(1).stores({
      users: 'id, name, role',
      ojt_docs: 'id, team, step, author_id, updated_at',
      learning_records: 'id, user_id, doc_id',
      sync_queue: '++id, table, action, created_at'
    });

    // 온라인 상태 확인
    const isOnline = () => navigator.onLine;

    // 캐시 전체 클리어 (로그아웃 또는 버전 업그레이드 시 사용)
    const clearAllCache = async () => {
      try {
        await localDb.users.clear();
        await localDb.ojt_docs.clear();
        await localDb.learning_records.clear();
        await localDb.sync_queue.clear();
        console.log('All cache cleared successfully');
      } catch (e) {
        console.error('Cache clear error:', e);
      }
    };

    // 캐시 버전 체크 및 마이그레이션 (앱 시작 시 실행)
    const checkCacheVersion = async () => {
      const storedVersion = parseInt(localStorage.getItem(CACHE_VERSION_KEY) || '0', 10);

      if (storedVersion < CACHE_VERSION) {
        console.log(`Cache version upgrade: ${storedVersion} → ${CACHE_VERSION}`);
        await clearAllCache();
        localStorage.setItem(CACHE_VERSION_KEY, String(CACHE_VERSION));
        console.log('Cache migration completed');
      }
    };

    // 앱 시작 시 캐시 버전 체크 실행
    checkCacheVersion();

    // =========================================
    // 설정 (AI - Google Gemini API)
    // ⚠️ 보안 주의: 프로덕션 환경에서는 Supabase Edge Function으로 프록시 권장
    // 현재 키는 HTTP Referer 제한 설정됨 (ggp-ojt-v2.vercel.app만 허용)
    // =========================================
    const GEMINI_API_KEY = "AIzaSyCvH1uc1OJ7EHmiWfsjbKVFH-X8KuvXH2I"; // Google AI Studio에서 발급
    const GEMINI_MODEL = "gemini-2.0-flash-exp"; // 무료 티어: gemini-2.0-flash-exp (권장)
    const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models";

    // =========================================
    // 스텝 분할 설정
    // =========================================
    const STEP_TIME_LIMIT = 40; // 분 (한 스텝당 최대 학습 시간)
    const CHARS_PER_MINUTE = 500; // 분당 읽기 가능 글자 수 (한국어 기준)
    const MAX_CHARS_PER_STEP = STEP_TIME_LIMIT * CHARS_PER_MINUTE; // 20,000자

    // 콘텐츠 분량 추정 함수
    function estimateReadingTime(text) {
      if (!text) return 0;
      const charCount = text.length;
      return Math.ceil(charCount / CHARS_PER_MINUTE);
    }

    // 필요한 스텝 수 계산
    function calculateRequiredSteps(text) {
      if (!text) return 1;
      const charCount = text.length;
      return Math.max(1, Math.ceil(charCount / MAX_CHARS_PER_STEP));
    }

    // 텍스트를 스텝별로 분할 (의미 단위로 분할 시도)
    function splitContentForSteps(text, numSteps) {
      if (numSteps <= 1) return [text];

      const segments = [];
      const avgLength = Math.ceil(text.length / numSteps);

      // 줄바꿈, 문단, 또는 문장 단위로 분할 시도
      const paragraphs = text.split(/\n\n+/);

      if (paragraphs.length >= numSteps) {
        // 문단이 충분하면 문단 단위로 분배
        const perStep = Math.ceil(paragraphs.length / numSteps);
        for (let i = 0; i < numSteps; i++) {
          const start = i * perStep;
          const end = Math.min(start + perStep, paragraphs.length);
          segments.push(paragraphs.slice(start, end).join('\n\n'));
        }
      } else {
        // 문단이 부족하면 글자 수 기준으로 분할
        let currentPos = 0;
        for (let i = 0; i < numSteps; i++) {
          const targetEnd = currentPos + avgLength;
          let actualEnd = targetEnd;

          // 문장 끝(.!?)을 찾아서 자연스럽게 분할
          if (i < numSteps - 1 && targetEnd < text.length) {
            const searchRange = text.substring(targetEnd - 100, targetEnd + 100);
            const sentenceEnd = searchRange.search(/[.!?。]\s/);
            if (sentenceEnd !== -1) {
              actualEnd = targetEnd - 100 + sentenceEnd + 2;
            }
          } else {
            actualEnd = text.length;
          }

          segments.push(text.substring(currentPos, actualEnd).trim());
          currentPos = actualEnd;
        }
      }

      return segments.filter(s => s.length > 0);
    }

    // =========================================
    // DB 헬퍼 (Dexie 캐시 + Supabase 동기화)
    // =========================================

    // Sync Queue 최대 재시도 횟수
    const MAX_SYNC_RETRIES = 3;

    // 오프라인 큐에 작업 추가
    const addToSyncQueue = async (table, action, data) => {
      await localDb.sync_queue.add({
        table,
        action,
        data,
        retryCount: 0,
        created_at: new Date().toISOString()
      });
    };

    // 오프라인 큐 처리 (온라인 복귀 시)
    const processSyncQueue = async () => {
      const queue = await localDb.sync_queue.toArray();

      for (const item of queue) {
        try {
          if (item.action === 'upsert') {
            await supabase.from(item.table).upsert(item.data);
          } else if (item.action === 'insert') {
            await supabase.from(item.table).insert(item.data);
          } else if (item.action === 'delete') {
            await supabase.from(item.table).delete().eq('id', item.data.id);
          }
          // 성공하면 큐에서 제거
          await localDb.sync_queue.delete(item.id);
        } catch (e) {
          console.error('Sync queue processing failed:', e);
          // 재시도 횟수 증가
          const retryCount = (item.retryCount || 0) + 1;
          if (retryCount >= MAX_SYNC_RETRIES) {
            // 최대 재시도 초과 시 큐에서 제거 (데이터 손실 방지 로그)
            console.error(`Sync item permanently failed after ${MAX_SYNC_RETRIES} retries:`, item);
            await localDb.sync_queue.delete(item.id);
          } else {
            // 재시도 횟수 업데이트
            await localDb.sync_queue.update(item.id, { retryCount });
          }
        }
      }
    };

    // 온라인 상태 변경 감지
    window.addEventListener('online', () => {
      console.log('Online - Processing sync queue...');
      processSyncQueue();
    });

    // 단일 조회 (캐시 우선, 온라인 시 동기화)
    const dbGet = async (storeName, key) => {
      // 1. 로컬 캐시 먼저 확인
      let cached = await localDb[storeName].get(key);

      // 2. 온라인이면 Supabase에서 최신 데이터 가져오기
      if (isOnline()) {
        try {
          const { data, error } = await supabase
            .from(storeName)
            .select("*")
            .eq("id", key)
            .maybeSingle();

          if (data) {
            // 캐시 업데이트
            await localDb[storeName].put(data);
            cached = data;
          }
        } catch (e) {
          console.error("dbGet sync error:", e);
        }
      }

      return cached;
    };

    // 전체 조회 (캐시 먼저 반환, 백그라운드 동기화)
    const dbGetAll = async (storeName, filters = {}) => {
      // 1. 로컬 캐시에서 먼저 조회
      let cached = [];

      try {
        if (storeName === "ojt_docs") {
          let collection = localDb.ojt_docs.toCollection();
          if (filters.team) {
            collection = localDb.ojt_docs.where('team').equals(filters.team);
          }
          cached = await collection.reverse().sortBy('updated_at');
          if (filters.authorId) {
            cached = cached.filter(doc => doc.author_id === filters.authorId);
          }
        } else if (storeName === "learning_records") {
          if (filters.userId) {
            cached = await localDb.learning_records.where('user_id').equals(filters.userId).toArray();
          } else {
            cached = await localDb.learning_records.toArray();
          }
        } else {
          cached = await localDb[storeName].toArray();
        }
      } catch (e) {
        console.error("Local cache read error:", e);
      }

      // 2. 온라인이면 백그라운드에서 Supabase 동기화
      if (isOnline()) {
        (async () => {
          try {
            let query = supabase.from(storeName).select("*");

            if (storeName === "ojt_docs") {
              query = query.order("created_at", { ascending: false });
              if (filters.team) query = query.eq("team", filters.team);
              if (filters.authorId) query = query.eq("author_id", filters.authorId);
            } else if (storeName === "learning_records") {
              if (filters.userId) query = query.eq("user_id", filters.userId);
            }

            const { data, error } = await query;

            if (data && !error) {
              // 캐시 완전 교체 (삭제된 데이터 정리)
              // 필터가 없는 전체 조회일 때만 clear 수행
              if (!filters.team && !filters.authorId && !filters.userId) {
                await localDb[storeName].clear();
              }
              await localDb[storeName].bulkPut(data);
            }
          } catch (e) {
            console.error("Background sync error:", e);
          }
        })();
      }

      return cached;
    };

    // 생성/수정 (로컬 먼저, 온라인 시 동기화)
    const dbPut = async (storeName, data) => {
      const now = new Date().toISOString();
      let localData = { ...data, updated_at: now };

      // Supabase 필드명으로 변환
      if (storeName === "users") {
        localData = {
          id: data.id,
          name: data.name,
          role: data.role,
          department: data.department || null,
          updated_at: now
        };
      } else if (storeName === "ojt_docs") {
        localData = {
          id: data.id,
          title: data.title,
          team: data.team,
          step: data.step,
          sections: data.sections,
          quiz: data.quiz,
          author_id: data.authorId,
          author_name: data.author,
          estimated_minutes: data.estimatedMinutes || 30,
          updated_at: now
        };
      }

      // 1. 로컬 캐시에 즉시 저장
      await localDb[storeName].put(localData);

      // 2. 온라인이면 Supabase에 동기화
      if (isOnline()) {
        try {
          if (storeName === "users") {
            // users는 insert/update 분리
            let { error } = await supabase.from("users").insert(localData).select().single();
            if (error && error.code === "23505") {
              await supabase.from("users")
                .update({ name: localData.name, role: localData.role, department: localData.department })
                .eq("id", localData.id);
            }
          } else {
            await supabase.from(storeName).upsert(localData);
          }
        } catch (e) {
          console.error("dbPut sync error:", e);
          await addToSyncQueue(storeName, 'upsert', localData);
        }
      } else {
        await addToSyncQueue(storeName, 'upsert', localData);
      }

      return localData;
    };

    // 새 데이터 추가 (로컬 먼저, 온라인 시 동기화)
    const dbAdd = async (storeName, data) => {
      const now = new Date().toISOString();
      const newId = crypto.randomUUID();
      let localData = { ...data, id: newId, created_at: now, updated_at: now };

      // Supabase 필드명으로 변환
      if (storeName === "ojt_docs") {
        localData = {
          id: newId,
          title: data.title,
          team: data.team,
          step: data.step,
          sections: data.sections,
          quiz: data.quiz,
          author_id: data.authorId,
          author_name: data.author,
          estimated_minutes: data.estimatedMinutes || 30,
          created_at: now,
          updated_at: now
        };
      } else if (storeName === "learning_records") {
        localData = {
          id: newId,
          user_id: data.userId,
          doc_id: data.docId,
          score: data.score,
          total_questions: data.totalQuestions || 4,
          passed: data.passed,
          completed_at: now
        };
      }

      // 1. 로컬 캐시에 즉시 저장
      await localDb[storeName].add(localData);

      // 2. 온라인이면 Supabase에 동기화
      if (isOnline()) {
        try {
          await supabase.from(storeName).insert(localData);
        } catch (e) {
          console.error("dbAdd sync error:", e);
          await addToSyncQueue(storeName, 'insert', localData);
        }
      } else {
        await addToSyncQueue(storeName, 'insert', localData);
      }

      return newId;
    };

    // 삭제 (로컬 먼저, 온라인 시 동기화)
    const dbDelete = async (storeName, key) => {
      // 1. 로컬 캐시에서 삭제
      await localDb[storeName].delete(key);

      // 2. 온라인이면 Supabase에서 삭제
      if (isOnline()) {
        try {
          await supabase.from(storeName).delete().eq("id", key);
        } catch (e) {
          console.error("dbDelete sync error:", e);
          await addToSyncQueue(storeName, 'delete', { id: key });
        }
      } else {
        await addToSyncQueue(storeName, 'delete', { id: key });
      }

      return true;
    };

    // =========================================
    // Constants
    // =========================================
    const TEAMS = ["공통 (Common)", "개발팀 (Dev)", "디자인팀 (Design)", "기획팀 (PM)", "인사팀 (HR)", "영업팀 (Sales)"];
    const STEPS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const QUIZ_PASS_THRESHOLD = 3;
    const INPUT_TYPES = [
      { id: 'text', label: '직접 입력', icon: 'text', desc: '텍스트를 직접 작성' },
      { id: 'url', label: 'URL', icon: 'globe', desc: '웹페이지 텍스트 추출' },
      { id: 'pdf', label: 'PDF', icon: 'file', desc: 'PDF 파일에서 추출' },
    ];

    // =========================================
    // Content Extraction Functions
    // =========================================

    // PDF 텍스트 추출
    async function extractPdfText(file, setProgress) {
      setProgress && setProgress("PDF 로딩 중...");
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

      let fullText = '';
      const numPages = pdf.numPages;

      for (let i = 1; i <= numPages; i++) {
        setProgress && setProgress(`PDF 페이지 ${i}/${numPages} 처리 중...`);
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map(item => item.str).join(' ');
        fullText += pageText + '\n\n';
      }

      return fullText.trim();
    }

    // URL 텍스트 추출 (CORS 프록시 사용)
    async function extractUrlText(url, setProgress) {
      setProgress && setProgress("웹페이지 가져오는 중...");

      // 여러 CORS 프록시 시도
      const corsProxies = [
        `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
        `https://corsproxy.io/?${encodeURIComponent(url)}`,
      ];

      let html = null;
      for (const proxyUrl of corsProxies) {
        try {
          const response = await fetch(proxyUrl);
          if (response.ok) {
            html = await response.text();
            break;
          }
        } catch (e) {
          console.log("Proxy failed:", proxyUrl);
        }
      }

      if (!html) {
        throw new Error("웹페이지를 가져올 수 없습니다. URL을 확인해주세요.");
      }

      setProgress && setProgress("텍스트 추출 중...");

      // HTML을 텍스트로 변환 (간단한 파싱)
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      // 스크립트, 스타일 태그 제거
      const removeElements = doc.querySelectorAll('script, style, nav, footer, header, aside, noscript');
      removeElements.forEach(el => el.remove());

      // 본문 텍스트 추출 (우선순위: article > main > body)
      const article = doc.querySelector('article');
      const main = doc.querySelector('main');
      const body = doc.body;

      const targetElement = article || main || body;
      let text = targetElement ? targetElement.innerText : '';

      // 중복 공백/줄바꿈 정리
      text = text.replace(/\s+/g, ' ').replace(/\n\s*\n/g, '\n\n').trim();

      // 최대 15000자로 제한
      if (text.length > 15000) {
        text = text.substring(0, 15000) + '...\n\n[내용이 너무 길어 일부만 추출되었습니다]';
      }

      return text;
    }

    // =========================================
    // AI Logic (Google Gemini API)
    // =========================================

    // Gemini API 상태 체크
    async function checkAIStatus() {
      // API 키가 설정되어 있으면 온라인으로 간주 (실제 호출 시 검증됨)
      if (GEMINI_API_KEY) {
        return {
          online: true,
          provider: 'gemini',
          model: GEMINI_MODEL
        };
      }

      return {
        online: false,
        provider: null,
        model: null
      };
    }

    // Gemini AI 상태 체크 함수 별칭 (기존 코드 호환성)
    const checkGeminiStatus = checkAIStatus;

    async function generateOJTContent(rawText, team, step, setProgress, totalSteps = 1) {
      const stepInfo = totalSteps > 1 ? ` (총 ${totalSteps}개 스텝 중 ${step}번째 스텝)` : '';
      const prompt = `/no_think
당신은 10년 경력의 기업 교육 설계 전문가입니다. 비정형 업무 메모를 체계적인 신입사원 OJT 자료로 변환하는 것이 전문 분야입니다.

## 작업 요청
아래 [입력 텍스트]를 ${team} 부서 신입사원을 위한 Step ${step}${stepInfo} OJT 교육 자료로 변환해주세요.

## 콘텐츠 작성 가이드라인

### 1. 섹션 구성 원칙 (3-5개 섹션)
각 섹션은 다음 구조를 따르세요:
- **학습 목표**: 이 섹션을 통해 무엇을 배울 수 있는지 한 문장으로
- **핵심 내용**: 신입사원이 반드시 알아야 할 내용 (구체적 절차, 규칙, 용어 설명)
- **실무 예시**: 실제 업무에서 어떻게 적용되는지 구체적 상황 예시
- **주의사항**: 신입사원이 자주 실수하는 부분, 주의할 점

### 2. 글쓰기 품질 기준
- 모호한 표현 금지: "적절히", "필요에 따라" 대신 구체적 기준 제시
- 전문 용어는 첫 등장 시 괄호 안에 설명 추가
- 순서가 있는 작업은 번호 매기기 사용
- 한 문단은 3-4문장, 한 섹션은 400-800자

### 3. 퀴즈 설계 원칙 (정확히 20문제)
문제 유형 배분:
- 기억형 (40%): 용어, 절차, 규칙을 정확히 기억하는지 확인
- 이해형 (35%): 왜 그렇게 하는지 이유를 이해했는지 확인
- 적용형 (25%): 실제 상황에서 어떻게 적용할지 판단

퀴즈 품질 기준:
- 질문은 명확하고 구체적으로 (무엇을, 언제, 어떻게)
- 정답은 본문 내용에 근거해야 함
- 오답 선지는 그럴듯하지만 명확히 틀린 내용 (흔한 오해 반영)
- 모든 선지 길이는 비슷하게 유지

## 입력 텍스트
${rawText}

## 출력 형식
반드시 아래 JSON 형식으로만 응답하세요. JSON 외 다른 텍스트 없이 출력하세요:

{
  "title": "명확하고 구체적인 문서 제목",
  "estimatedMinutes": 25,
  "sections": [
    {
      "title": "1. 섹션 제목",
      "content": "**학습 목표**: ...\\n\\n**핵심 내용**:\\n...\\n\\n**실무 예시**:\\n...\\n\\n**주의사항**:\\n..."
    }
  ],
  "quiz": [
    {
      "id": 1,
      "question": "구체적인 질문 내용?",
      "options": ["선지A (20자 내외)", "선지B (20자 내외)", "선지C (20자 내외)", "선지D (20자 내외)"],
      "answer": 0
    }
  ]
}

## 체크리스트
- [ ] 섹션 3-5개, 각 섹션 400-800자
- [ ] 퀴즈 정확히 20개
- [ ] answer는 정답 인덱스 (0, 1, 2, 3 중 하나)
- [ ] estimatedMinutes는 40 이하
- [ ] JSON 문법 오류 없음`;

      try {
        // Gemini API 호출
        setProgress && setProgress("Gemini AI 연결 중...");

        const geminiPrompt = prompt.replace('/no_think\n', ''); // Gemini는 /no_think 불필요

        const response = await fetch(
          `${GEMINI_API_URL}/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [{
                parts: [{ text: geminiPrompt }]
              }],
              generationConfig: {
                temperature: 0.3,
                maxOutputTokens: 8192
              }
            })
          }
        );

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(`Gemini API 오류: ${response.status} - ${errorData.error?.message || ''}`);
        }

        setProgress && setProgress("Gemini AI 응답 처리 중...");
        const data = await response.json();

        // Gemini 응답 구조에서 텍스트 추출
        const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        console.log("Gemini raw response:", responseText.substring(0, 500));

        // 마크다운 코드블록 제거 (```json ... ``` 또는 ``` ... ```)
        let cleanedResponse = responseText
          .replace(/```json\s*/gi, '')
          .replace(/```\s*/g, '')
          .trim();

        // JSON 추출 (응답에서 JSON 부분만 파싱)
        const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          console.error("No JSON found in response:", cleanedResponse.substring(0, 200));
          throw new Error("JSON 형식 응답을 받지 못했습니다.");
        }

        let jsonStr = jsonMatch[0];

        // JSON 문자열 정리 함수
        function cleanJsonString(str) {
          // 1. 제어 문자 제거 (탭과 줄바꿈은 유지)
          str = str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');

          // 2. JSON 문자열 내부의 실제 줄바꿈을 \\n으로 변환
          // 문자열 내부(따옴표 사이)의 줄바꿈만 처리
          str = str.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (match) => {
            return match
              .replace(/\n/g, '\\n')
              .replace(/\r/g, '\\r')
              .replace(/\t/g, '\\t');
          });

          // 3. JSON 구조 밖의 줄바꿈 제거
          str = str.replace(/\n/g, ' ').replace(/\r/g, '');

          // 4. 잘못된 유니코드 이스케이프 수정
          str = str.replace(/\\u(?![0-9a-fA-F]{4})/g, '\\\\u');

          return str;
        }

        let result;
        try {
          const cleanedJson = cleanJsonString(jsonStr);
          result = JSON.parse(cleanedJson);
        } catch (parseError) {
          console.error("JSON Parse Error:", parseError.message);
          console.error("Attempted to parse:", jsonStr.substring(0, 300));

          // 수동 파싱 시도 (regex로 각 필드 추출)
          try {
            const titleMatch = cleanedResponse.match(/"title"\s*:\s*"([^"]+)"/);
            const title = titleMatch ? titleMatch[1] : "생성된 문서";

            // sections 추출 시도
            const sections = [];
            const sectionRegex = /\{\s*"title"\s*:\s*"([^"]+)"\s*,\s*"content"\s*:\s*"([^"]+)"\s*\}/g;
            let sectionMatch;
            // sections 배열 부분만 추출
            const sectionsArrayMatch = cleanedResponse.match(/"sections"\s*:\s*\[([\s\S]*?)\]/);
            if (sectionsArrayMatch) {
              const sectionsStr = sectionsArrayMatch[1];
              while ((sectionMatch = sectionRegex.exec(sectionsStr)) !== null) {
                sections.push({ title: sectionMatch[1], content: sectionMatch[2] });
              }
            }

            // quiz 추출 시도
            const quiz = [];
            const quizArrayMatch = cleanedResponse.match(/"quiz"\s*:\s*\[([\s\S]*?)\]/);
            if (quizArrayMatch) {
              const quizRegex = /\{\s*"id"\s*:\s*(\d+)\s*,\s*"question"\s*:\s*"([^"]+)"\s*,\s*"options"\s*:\s*\[([^\]]+)\]\s*,\s*"answer"\s*:\s*(\d+)\s*\}/g;
              let quizMatch;
              while ((quizMatch = quizRegex.exec(quizArrayMatch[1])) !== null) {
                const options = quizMatch[3].match(/"([^"]+)"/g)?.map(o => o.replace(/"/g, '')) || [];
                quiz.push({
                  id: parseInt(quizMatch[1]),
                  question: quizMatch[2],
                  options: options,
                  answer: parseInt(quizMatch[4])
                });
              }
            }

            result = {
              title: title,
              sections: sections.length > 0 ? sections : [{ title: "내용", content: "AI 응답에서 섹션을 파싱하지 못했습니다." }],
              quiz: quiz
            };
            console.warn("Used regex fallback for JSON parsing");
          } catch (regexError) {
            console.error("Regex parsing also failed:", regexError);
            result = {
              title: "생성 실패",
              sections: [{ title: "오류", content: "AI 응답을 파싱하지 못했습니다. 다시 시도해주세요." }],
              quiz: []
            };
          }
        }

        // 퀴즈가 20개 미만이면 더미로 채우기
        while (result.quiz && result.quiz.length < 20) {
          result.quiz.push({
            id: result.quiz.length + 1,
            question: `${result.title} 관련 추가 문제 ${result.quiz.length + 1}`,
            options: ["정답", "오답1", "오답2", "오답3"],
            answer: 0
          });
        }

        return result;

      } catch (error) {
        console.error("AI Generation Error:", error);
        throw error;
      }
    }

    // =========================================
    // Main App
    // =========================================
    function App() {
      // User State
      const [user, setUser] = useState(null);
      const [isLoadingAuth, setIsLoadingAuth] = useState(true);

      // AI Status (Gemini)
      const [aiStatus, setAiStatus] = useState({ online: false, provider: null, model: null });
      const [showSettings, setShowSettings] = useState(false);

      // App State
      const [viewState, setViewState] = useState('loading');

      // Mentor State
      const [inputType, setInputType] = useState('text'); // 'text', 'url', 'pdf'
      const [inputTitle, setInputTitle] = useState('');
      const [rawInput, setRawInput] = useState('');
      const [urlInput, setUrlInput] = useState('');
      const [pdfFile, setPdfFile] = useState(null);
      // Quill Editor
      const quillRef = useRef(null);
      const quillInstanceRef = useRef(null);
      const [inputTeam, setInputTeam] = useState(TEAMS[0]);
      const [inputStep, setInputStep] = useState(1);
      const [isCustomTeam, setIsCustomTeam] = useState(false);
      const [isCustomStep, setIsCustomStep] = useState(false);
      const [isProcessing, setIsProcessing] = useState(false);
      const [processingStatus, setProcessingStatus] = useState('');
      const [generatedDoc, setGeneratedDoc] = useState(null);
      const [generatedDocs, setGeneratedDocs] = useState([]); // 분할된 여러 문서
      const [myDocs, setMyDocs] = useState([]);
      const [autoSplit, setAutoSplit] = useState(true); // 자동 스텝 분할 옵션
      const [estimatedTime, setEstimatedTime] = useState(0); // 예상 학습 시간
      const [requiredSteps, setRequiredSteps] = useState(1); // 필요 스텝 수

      // Mentee State
      const [publicDocs, setPublicDocs] = useState([]);
      const [selectedTeam, setSelectedTeam] = useState(null);
      const [selectedDoc, setSelectedDoc] = useState(null);

      // Quiz State
      const [quizMode, setQuizMode] = useState(false);
      const [activeQuizSet, setActiveQuizSet] = useState([]);
      const [currentQuizIndex, setCurrentQuizIndex] = useState(0);
      const [selectedAnswers, setSelectedAnswers] = useState({});
      const [quizSubmitted, setQuizSubmitted] = useState(false);
      const [score, setScore] = useState(0);
      const [passed, setPassed] = useState(false);

      // =========================================
      // Effects
      // =========================================

      // AI 상태 체크 (Gemini)
      useEffect(() => {
        const checkStatus = async () => {
          const status = await checkGeminiStatus();
          setAiStatus(status);
        };
        checkStatus();
        const interval = setInterval(checkStatus, 30000); // 30초마다 체크
        return () => clearInterval(interval);
      }, []);

      // 입력 내용 변경 시 예상 학습 시간 및 필요 스텝 수 계산
      useEffect(() => {
        if (rawInput) {
          const time = estimateReadingTime(rawInput);
          const steps = calculateRequiredSteps(rawInput);
          setEstimatedTime(time);
          setRequiredSteps(steps);
        } else {
          setEstimatedTime(0);
          setRequiredSteps(1);
        }
      }, [rawInput]);

      // Quill 에디터 초기화
      useEffect(() => {
        if (inputType === 'text' && quillRef.current && !quillInstanceRef.current) {
          // Quill 인스턴스 생성
          quillInstanceRef.current = new Quill(quillRef.current, {
            theme: 'snow',
            placeholder: '교육 내용을 자유롭게 입력하세요...\n\n• 서식 도구를 사용하여 제목, 목록, 강조 등을 추가할 수 있습니다\n• Ctrl+B: 굵게, Ctrl+I: 기울임, Ctrl+U: 밑줄',
            modules: {
              toolbar: [
                [{ 'header': [1, 2, 3, false] }],
                ['bold', 'italic', 'underline', 'strike'],
                [{ 'color': [] }, { 'background': [] }],
                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                [{ 'indent': '-1'}, { 'indent': '+1' }],
                ['blockquote', 'code-block'],
                ['link'],
                ['clean']
              ]
            }
          });

          // 텍스트 변경 시 rawInput 업데이트
          quillInstanceRef.current.on('text-change', () => {
            const text = quillInstanceRef.current.getText().trim();
            setRawInput(text);
          });
        }

        // inputType이 변경되면 Quill 인스턴스 정리
        return () => {
          if (inputType !== 'text' && quillInstanceRef.current) {
            quillInstanceRef.current = null;
          }
        };
      }, [inputType, viewState]);

      // 사용자 프로필 로드 및 뷰 상태 설정 (공통 함수)
      const loadUserProfile = async (session) => {
        console.log("loadUserProfile called, session:", session?.user?.email);

        if (!session?.user) {
          console.log("No session user, redirecting to login");
          setUser(null);
          setViewState('login');
          setIsLoadingAuth(false);
          return;
        }

        try {
          console.log("Fetching profile for user:", session.user.id);
          const profile = await dbGet("users", session.user.id);
          console.log("Profile fetched:", profile);

          if (profile && profile.role) {
            setUser(profile);
            if (profile.role === 'admin') setViewState('admin_dashboard');
            else if (profile.role === 'mentor') setViewState('mentor_dashboard');
            else if (profile.role === 'mentee') setViewState('mentee_list');
            else setViewState('role_select');
          } else {
            // 프로필이 없거나 역할이 없으면 역할 선택 화면으로
            console.log("No profile or role, showing role select");
            setUser({
              id: session.user.id,
              name: session.user.user_metadata?.full_name || session.user.email?.split('@')[0] || 'User',
              email: session.user.email,
              role: null
            });
            setViewState('role_select');
          }
        } catch (e) {
          console.error("Load user profile error:", e);
          // 에러 발생 시에도 역할 선택 화면으로 (로그인 상태는 유지)
          setUser({
            id: session.user.id,
            name: session.user.user_metadata?.full_name || session.user.email?.split('@')[0] || 'User',
            email: session.user.email,
            role: null
          });
          setViewState('role_select');
        } finally {
          // 항상 로딩 상태 종료
          setIsLoadingAuth(false);
        }
      };

      // 초기 로드: Supabase Auth 세션 확인
      useEffect(() => {
        let isMounted = true;
        let authHandled = false;

        // 안전장치: 10초 후에도 로딩 중이면 로그인 화면으로 (타임아웃)
        const timeoutId = setTimeout(() => {
          if (isMounted && !authHandled) {
            console.warn("Auth timeout - falling back to login");
            setIsLoadingAuth(false);
            setViewState('login');
          }
        }, 10000);

        // onAuthStateChange가 모든 세션 이벤트를 처리
        // INITIAL_SESSION: 페이지 로드 시 기존 세션 복원
        // SIGNED_IN: 새 로그인
        // SIGNED_OUT: 로그아웃
        // TOKEN_REFRESHED: 토큰 갱신 (무시)
        const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {
          console.log('Auth event:', event, session?.user?.email);

          if (!isMounted) return;
          authHandled = true;
          clearTimeout(timeoutId);

          // 토큰 갱신은 UI 변경 불필요
          if (event === 'TOKEN_REFRESHED') return;

          if (event === 'SIGNED_OUT') {
            setUser(null);
            setViewState('login');
            setIsLoadingAuth(false);
            return;
          }

          // INITIAL_SESSION 또는 SIGNED_IN: 프로필 로드
          if (event === 'INITIAL_SESSION' || event === 'SIGNED_IN') {
            if (session?.user) {
              await loadUserProfile(session);
              // loadUserProfile에서 setIsLoadingAuth(false) 호출됨
            } else {
              setViewState('login');
              setIsLoadingAuth(false);
            }
          }
        });

        return () => {
          isMounted = false;
          clearTimeout(timeoutId);
          subscription.unsubscribe();
        };
      }, []);

      // 멘토: 내 문서 로드
      useEffect(() => {
        if (!user || user.role !== 'mentor') return;
        const loadMyDocs = async () => {
          const docs = await dbGetAll("ojt_docs", { authorId: user.id });
          // Supabase 필드명을 앱 형식으로 매핑
          const mapped = docs.map(doc => ({
            ...doc,
            authorId: doc.author_id,
            author: doc.author_name,
            estimatedMinutes: doc.estimated_minutes,
            createdAt: new Date(doc.created_at).getTime()
          }));
          setMyDocs(mapped);
        };
        loadMyDocs();
      }, [user, generatedDoc]); // generatedDoc 변경 시 리로드

      // 멘티: 모든 문서 로드
      useEffect(() => {
        if (!user || user.role !== 'mentee') return;
        const loadPublicDocs = async () => {
          const docs = await dbGetAll("ojt_docs");
          // Supabase 필드명을 앱 형식으로 매핑
          const mapped = docs.map(doc => ({
            ...doc,
            authorId: doc.author_id,
            author: doc.author_name,
            estimatedMinutes: doc.estimated_minutes,
            createdAt: new Date(doc.created_at).getTime()
          }));
          setPublicDocs(mapped);
        };
        loadPublicDocs();
      }, [user]);

      // =========================================
      // Auth Handlers
      // =========================================
      const handleGoogleLogin = async () => {
        try {
          const { error } = await supabase.auth.signInWithOAuth({
            provider: 'google',
            options: {
              redirectTo: window.location.origin
            }
          });
          if (error) throw error;
        } catch (e) {
          console.error("Google login error:", e);
          alert("Google 로그인 중 오류가 발생했습니다: " + e.message);
        }
      };

      const handleRoleSelect = async (selectedRole) => {
        if (!user) return;
        try {
          const userData = {
            id: user.id,
            name: user.name,
            role: selectedRole,
            department: null
          };
          await dbPut("users", userData);
          setUser(userData);

          if (selectedRole === 'mentor') setViewState('mentor_dashboard');
          else setViewState('mentee_list');
        } catch (e) {
          console.error("Role save error:", e);
          alert("역할 저장 중 오류가 발생했습니다.");
        }
      };

      const handleLogout = async () => {
        try {
          // 캐시 먼저 클리어 (다른 사용자 데이터 노출 방지)
          await clearAllCache();
          await supabase.auth.signOut();
          setUser(null);
          setViewState('login');
        } catch (e) {
          console.error("Logout error:", e);
        }
      };

      // =========================================
      // Mentor Handlers
      // =========================================
      const handleGenerate = async () => {
        // 입력 타입에 따른 검증
        if (inputType === 'text' && !rawInput.trim()) {
          alert("텍스트를 입력해주세요.");
          return;
        }
        if (inputType === 'url' && !urlInput.trim()) {
          alert("URL을 입력해주세요.");
          return;
        }
        if (inputType === 'pdf' && !pdfFile) {
          alert("PDF 파일을 선택해주세요.");
          return;
        }
        if (!aiStatus.online) {
          alert("Gemini AI 서비스에 연결할 수 없습니다.\n\nAPI 키를 확인해주세요.");
          return;
        }

        setIsProcessing(true);
        setGeneratedDoc(null);
        setGeneratedDocs([]);
        setProcessingStatus("콘텐츠 추출 중...");

        try {
          // 입력 타입에 따라 텍스트 추출
          let contentText = '';

          if (inputType === 'text') {
            // Quill에서 서식 있는 HTML과 플레인 텍스트 모두 가져오기
            if (quillInstanceRef.current) {
              const html = quillInstanceRef.current.root.innerHTML;
              const plainText = quillInstanceRef.current.getText().trim();
              // HTML이 의미 있는 서식을 포함하면 HTML 사용, 아니면 플레인 텍스트 사용
              const hasFormatting = /<(h[1-6]|strong|em|u|ol|ul|li|blockquote|pre)/.test(html);
              contentText = hasFormatting ? html : plainText;
            } else {
              contentText = rawInput;
            }
          } else if (inputType === 'url') {
            contentText = await extractUrlText(urlInput, setProcessingStatus);
            setRawInput(contentText); // 추출된 텍스트를 rawInput에도 저장
          } else if (inputType === 'pdf') {
            contentText = await extractPdfText(pdfFile, setProcessingStatus);
            setRawInput(contentText); // 추출된 텍스트를 rawInput에도 저장
          }

          if (!contentText.trim()) {
            throw new Error("추출된 텍스트가 없습니다.");
          }

          // 자동 분할 여부 확인
          const numSteps = autoSplit ? calculateRequiredSteps(contentText) : 1;

          if (numSteps > 1) {
            // 여러 스텝으로 분할 생성
            const segments = splitContentForSteps(contentText, numSteps);
            const results = [];
            const baseStep = parseInt(inputStep);
            const baseTitle = inputTitle.trim();

            for (let i = 0; i < segments.length; i++) {
              const stepNum = baseStep + i;
              setProcessingStatus(`AI 생성 중... (${i + 1}/${segments.length} 스텝)`);

              const aiResult = await generateOJTContent(
                segments[i],
                inputTeam,
                stepNum,
                setProcessingStatus,
                segments.length
              );

              const stepTitle = baseTitle
                ? `${baseTitle} - Step ${stepNum}`
                : `${aiResult.title} - Step ${stepNum}`;

              const finalDoc = {
                ...aiResult,
                title: stepTitle,
                team: inputTeam,
                step: stepNum,
                totalSteps: segments.length,
                stepIndex: i + 1
              };

              results.push(finalDoc);
            }

            setGeneratedDocs(results);
            setGeneratedDoc(results[0]); // 첫 번째 문서를 미리보기에 표시
            setProcessingStatus("");
          } else {
            // 단일 스텝 생성
            setProcessingStatus("AI 생성 시작...");
            const aiResult = await generateOJTContent(contentText, inputTeam, inputStep, setProcessingStatus);
            const finalTitle = inputTitle.trim() || aiResult.title;
            setInputTitle(finalTitle);
            const finalDoc = { ...aiResult, title: finalTitle, team: inputTeam, step: parseInt(inputStep) };
            setGeneratedDoc(finalDoc);
            setGeneratedDocs([finalDoc]);
            setProcessingStatus("");
          }
        } catch (error) {
          alert(`오류: ${error.message}`);
          setProcessingStatus("");
        }

        setIsProcessing(false);
      };

      const handleSaveToDB = async () => {
        if (!user || (!generatedDoc && generatedDocs.length === 0)) return;

        try {
          const docsToSave = generatedDocs.length > 0 ? generatedDocs : [generatedDoc];
          let savedCount = 0;

          for (const doc of docsToSave) {
            const docToSave = {
              ...doc,
              title: doc.title || inputTitle || "제목 없음",
              team: inputTeam,
              step: doc.step || parseInt(inputStep),
              createdAt: Date.now() + savedCount, // 순서 유지를 위해 약간의 차이
              author: user.name,
              authorId: user.id
            };
            await dbAdd("ojt_docs", docToSave);
            savedCount++;
          }

          alert(`${savedCount}개 문서가 저장되었습니다.`);
          setGeneratedDoc(null);
          setGeneratedDocs([]);
          setRawInput("");
          setUrlInput("");
          setPdfFile(null);
          setInputTitle("");
          // Quill 에디터 초기화
          if (quillInstanceRef.current) {
            quillInstanceRef.current.setText('');
          }
          // 목록 새로고침
          const allDocs = await dbGetAll("ojt_docs");
          const filtered = allDocs.filter(doc => doc.authorId === user.id);
          filtered.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
          setMyDocs(filtered);
        } catch (e) {
          console.error("Save error:", e);
          alert("저장 중 오류가 발생했습니다.");
        }
      };

      const handleDeleteDoc = async (docId) => {
        if (!confirm("정말 삭제하시겠습니까?")) return;
        try {
          await dbDelete("ojt_docs", docId);
          setMyDocs(prev => prev.filter(d => d.id !== docId));
        } catch (e) {
          console.error("Delete error:", e);
        }
      };

      // =========================================
      // Mentee Handlers
      // =========================================
      const handleSelectDoc = (doc) => {
        setSelectedDoc(doc);
        setQuizMode(false);
        setViewState('mentee_study');
      };

      const startQuizSession = () => {
        if (!selectedDoc || !selectedDoc.quiz) return;
        const fullPool = [...selectedDoc.quiz];
        for (let i = fullPool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [fullPool[i], fullPool[j]] = [fullPool[j], fullPool[i]];
        }
        setActiveQuizSet(fullPool.slice(0, 4));
        setQuizMode(true);
        setSelectedAnswers({});
        setQuizSubmitted(false);
        setCurrentQuizIndex(0);
        setScore(0);
        setPassed(false);
      };

      const handleAnswerSelect = (qIndex, optionIndex) => {
        if (quizSubmitted) return;
        setSelectedAnswers(prev => ({ ...prev, [qIndex]: optionIndex }));
      };

      const submitQuiz = () => {
        if (!activeQuizSet.length) return;
        let correctCount = 0;
        activeQuizSet.forEach((q, idx) => {
          if (selectedAnswers[idx] === q.answer) correctCount++;
        });
        setScore(correctCount);
        setPassed(correctCount >= QUIZ_PASS_THRESHOLD);
        setQuizSubmitted(true);
      };

      // =========================================
      // Views
      // =========================================

      const AIStatusBadge = () => {
        // AI 온라인 상태
        if (aiStatus.online) {
          return (
            <div className="flex items-center gap-2 px-3 py-1 rounded-full text-xs font-bold bg-blue-100 text-blue-700">
              <Icon name="server" className="w-3 h-3" />
              Gemini: {GEMINI_MODEL}
            </div>
          );
        }

        // AI 오프라인 상태
        return (
          <div className="flex items-center gap-2 px-3 py-1 rounded-full text-xs font-bold bg-red-100 text-red-700">
            <Icon name="server" className="w-3 h-3" />
            AI 오프라인
          </div>
        );
      };

      const LoginPage = () => {
        return (
          <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-indigo-50 via-white to-purple-50 p-6">
            <div className="max-w-md w-full bg-white rounded-2xl shadow-2xl p-10 text-center">
              <div className="mb-8">
                <div className="w-20 h-20 bg-indigo-100 rounded-full flex items-center justify-center mx-auto mb-4">
                  <Icon name="brain" className="w-12 h-12 text-indigo-600" />
                </div>
                <h1 className="text-3xl font-bold text-slate-800 mb-2">OJT Master</h1>
                <p className="text-slate-500">AI 기반 온보딩 교육 플랫폼</p>
                <p className="text-xs text-slate-400 mt-1">Supabase + Gemini AI</p>
              </div>

              <div className="mb-6">
                <AIStatusBadge />
                {aiStatus.online && (
                  <p className="text-xs text-blue-600 mt-2">Google Gemini AI로 자료를 생성합니다</p>
                )}
              </div>

              <div className="space-y-4">
                <button
                  onClick={handleGoogleLogin}
                  className="w-full py-3 bg-white border-2 border-slate-200 text-slate-700 rounded-lg font-bold hover:bg-slate-50 hover:border-slate-300 transition-colors flex items-center justify-center gap-3"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                  </svg>
                  Google로 로그인
                </button>
                <p className="text-xs text-slate-400 mt-4">
                  Google 계정으로 안전하게 로그인하세요.
                </p>
              </div>
            </div>
          </div>
        );
      };

      const Header = () => {
        const getRoleBadgeColor = (role) => {
          switch (role) {
            case 'admin': return 'bg-red-600 text-white';
            case 'mentor': return 'bg-indigo-800 text-indigo-100';
            case 'mentee': return 'bg-green-600 text-white';
            default: return 'bg-slate-600 text-white';
          }
        };

        const handleHomeClick = () => {
          if (user?.role === 'admin') setViewState('admin_dashboard');
          else if (user?.role === 'mentor') setViewState('mentor_dashboard');
          else if (user?.role === 'mentee') { setViewState('mentee_list'); setSelectedTeam(null); }
        };

        return (
          <header className="bg-indigo-600 text-white p-4 shadow-md flex justify-between items-center sticky top-0 z-50">
            <div className="flex items-center gap-2 cursor-pointer" onClick={handleHomeClick}>
              <Icon name="brain" className="w-8 h-8" />
              <div>
                <h1 className="text-xl font-bold">OJT Master</h1>
                <p className="text-xs text-indigo-200">
                  {user ? `${user.role?.toUpperCase()} MODE` : 'Welcome'}
                </p>
              </div>
            </div>
            <div className="flex items-center gap-3">
              <AIStatusBadge />
              {user && (
                <>
                  <span className="text-sm hidden sm:block">{user.name}</span>
                  <span className={`px-3 py-1 rounded-full text-xs font-bold uppercase ${getRoleBadgeColor(user.role)}`}>
                    {user.role}
                  </span>
                  <button onClick={handleLogout} className="text-sm flex items-center gap-1 hover:text-red-200">
                    <Icon name="logout" className="w-4 h-4" /> 로그아웃
                  </button>
                </>
              )}
            </div>
          </header>
        );
      };

      // =========================================
      // Admin Dashboard Component
      // =========================================
      const AdminDashboard = () => {
        const [adminTab, setAdminTab] = useState('users'); // 'users', 'content', 'stats'
        const [allUsers, setAllUsers] = useState([]);
        const [allDocs, setAllDocs] = useState([]);
        const [allRecords, setAllRecords] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [selectedUser, setSelectedUser] = useState(null);
        const [showRoleModal, setShowRoleModal] = useState(false);
        const chartRef = useRef(null);
        const chartInstance = useRef(null);

        // 데이터 로드
        useEffect(() => {
          const loadAdminData = async () => {
            setIsLoading(true);
            try {
              // 모든 사용자 조회 (Admin RLS 정책 적용)
              const { data: users, error: usersError } = await supabase
                .from('users')
                .select('*')
                .order('created_at', { ascending: false });

              if (usersError) throw usersError;
              setAllUsers(users || []);

              // 모든 문서 조회
              const { data: docs, error: docsError } = await supabase
                .from('ojt_docs')
                .select('*')
                .order('created_at', { ascending: false });

              if (docsError) throw docsError;
              setAllDocs(docs || []);

              // 모든 학습 기록 조회 (Admin RLS 정책 적용)
              const { data: records, error: recordsError } = await supabase
                .from('learning_records')
                .select('*')
                .order('completed_at', { ascending: false });

              if (!recordsError) setAllRecords(records || []);
            } catch (e) {
              console.error('Admin data load error:', e);
              alert('관리자 데이터를 불러오는 중 오류가 발생했습니다.');
            } finally {
              setIsLoading(false);
            }
          };

          loadAdminData();
        }, []);

        // 차트 생성/업데이트
        useEffect(() => {
          if (adminTab === 'stats' && chartRef.current && allUsers.length > 0) {
            // 기존 차트 제거
            if (chartInstance.current) {
              chartInstance.current.destroy();
            }

            // 역할별 사용자 수 집계
            const roleCounts = allUsers.reduce((acc, user) => {
              acc[user.role] = (acc[user.role] || 0) + 1;
              return acc;
            }, {});

            const ctx = chartRef.current.getContext('2d');
            chartInstance.current = new Chart(ctx, {
              type: 'doughnut',
              data: {
                labels: ['관리자', '멘토', '멘티'],
                datasets: [{
                  data: [roleCounts.admin || 0, roleCounts.mentor || 0, roleCounts.mentee || 0],
                  backgroundColor: ['#dc2626', '#4f46e5', '#16a34a'],
                  borderWidth: 0
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { position: 'bottom' }
                }
              }
            });
          }

          return () => {
            if (chartInstance.current) {
              chartInstance.current.destroy();
            }
          };
        }, [adminTab, allUsers]);

        // 역할 변경 핸들러
        const handleRoleChange = async (userId, newRole) => {
          try {
            const { error } = await supabase
              .from('users')
              .update({ role: newRole })
              .eq('id', userId);

            if (error) throw error;

            // 로컬 상태 업데이트
            setAllUsers(prev => prev.map(u => u.id === userId ? { ...u, role: newRole } : u));
            setShowRoleModal(false);
            setSelectedUser(null);
            alert(`역할이 ${newRole}(으)로 변경되었습니다.`);
          } catch (e) {
            console.error('Role change error:', e);
            alert('역할 변경에 실패했습니다: ' + e.message);
          }
        };

        // 문서 삭제 핸들러
        const handleDeleteDoc = async (docId) => {
          if (!confirm('정말로 이 문서를 삭제하시겠습니까?')) return;

          try {
            const { error } = await supabase
              .from('ojt_docs')
              .delete()
              .eq('id', docId);

            if (error) throw error;

            setAllDocs(prev => prev.filter(d => d.id !== docId));
            alert('문서가 삭제되었습니다.');
          } catch (e) {
            console.error('Delete doc error:', e);
            alert('문서 삭제에 실패했습니다: ' + e.message);
          }
        };

        // 통계 계산
        const stats = useMemo(() => {
          const totalUsers = allUsers.length;
          const totalDocs = allDocs.length;
          const totalRecords = allRecords.length;
          const passedRecords = allRecords.filter(r => r.passed).length;
          const passRate = totalRecords > 0 ? Math.round((passedRecords / totalRecords) * 100) : 0;

          return { totalUsers, totalDocs, totalRecords, passRate };
        }, [allUsers, allDocs, allRecords]);

        if (isLoading) {
          return (
            <div className="flex items-center justify-center min-h-[calc(100vh-80px)]">
              <div className="text-center">
                <div className="w-12 h-12 border-4 border-indigo-600 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                <p className="text-slate-600">관리자 데이터를 불러오는 중...</p>
              </div>
            </div>
          );
        }

        return (
          <div className="max-w-7xl mx-auto px-4 py-8">
            <h2 className="text-2xl font-bold text-slate-800 mb-6 flex items-center gap-2">
              <Icon name="settings" className="w-7 h-7 text-red-600" />
              관리자 대시보드
            </h2>

            {/* 통계 카드 */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
              <div className="bg-white rounded-xl shadow p-6">
                <p className="text-sm text-slate-500">전체 사용자</p>
                <p className="text-3xl font-bold text-slate-800">{stats.totalUsers}</p>
              </div>
              <div className="bg-white rounded-xl shadow p-6">
                <p className="text-sm text-slate-500">전체 문서</p>
                <p className="text-3xl font-bold text-indigo-600">{stats.totalDocs}</p>
              </div>
              <div className="bg-white rounded-xl shadow p-6">
                <p className="text-sm text-slate-500">학습 기록</p>
                <p className="text-3xl font-bold text-green-600">{stats.totalRecords}</p>
              </div>
              <div className="bg-white rounded-xl shadow p-6">
                <p className="text-sm text-slate-500">퀴즈 통과율</p>
                <p className="text-3xl font-bold text-amber-600">{stats.passRate}%</p>
              </div>
            </div>

            {/* 탭 네비게이션 */}
            <div className="flex gap-2 mb-6 border-b border-slate-200">
              <button
                onClick={() => setAdminTab('users')}
                className={`px-4 py-2 font-medium transition-colors ${adminTab === 'users' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-slate-500 hover:text-slate-700'}`}
              >
                <Icon name="user" className="w-4 h-4 inline mr-1" /> 사용자 관리
              </button>
              <button
                onClick={() => setAdminTab('content')}
                className={`px-4 py-2 font-medium transition-colors ${adminTab === 'content' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-slate-500 hover:text-slate-700'}`}
              >
                <Icon name="book" className="w-4 h-4 inline mr-1" /> 콘텐츠 관리
              </button>
              <button
                onClick={() => setAdminTab('stats')}
                className={`px-4 py-2 font-medium transition-colors ${adminTab === 'stats' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-slate-500 hover:text-slate-700'}`}
              >
                <Icon name="server" className="w-4 h-4 inline mr-1" /> 통계
              </button>
            </div>

            {/* 사용자 관리 탭 */}
            {adminTab === 'users' && (
              <div className="bg-white rounded-xl shadow overflow-hidden">
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead className="bg-slate-50">
                      <tr>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">이름</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">역할</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">부서</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">가입일</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">작업</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                      {allUsers.map(u => (
                        <tr key={u.id} className="hover:bg-slate-50">
                          <td className="px-4 py-3 text-sm font-medium text-slate-800">{u.name}</td>
                          <td className="px-4 py-3">
                            <span className={`px-2 py-1 rounded-full text-xs font-bold uppercase ${
                              u.role === 'admin' ? 'bg-red-100 text-red-700' :
                              u.role === 'mentor' ? 'bg-indigo-100 text-indigo-700' :
                              'bg-green-100 text-green-700'
                            }`}>
                              {u.role}
                            </span>
                          </td>
                          <td className="px-4 py-3 text-sm text-slate-600">{u.department || '-'}</td>
                          <td className="px-4 py-3 text-sm text-slate-500">
                            {new Date(u.created_at).toLocaleDateString('ko-KR')}
                          </td>
                          <td className="px-4 py-3">
                            <button
                              onClick={() => { setSelectedUser(u); setShowRoleModal(true); }}
                              className="text-indigo-600 hover:text-indigo-800 text-sm font-medium"
                              disabled={u.id === user.id}
                            >
                              역할 변경
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                {allUsers.length === 0 && (
                  <div className="text-center py-8 text-slate-500">사용자가 없습니다.</div>
                )}
              </div>
            )}

            {/* 콘텐츠 관리 탭 */}
            {adminTab === 'content' && (
              <div className="bg-white rounded-xl shadow overflow-hidden">
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead className="bg-slate-50">
                      <tr>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">제목</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">팀</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">스텝</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">작성자</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">생성일</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">작업</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                      {allDocs.map(doc => (
                        <tr key={doc.id} className="hover:bg-slate-50">
                          <td className="px-4 py-3 text-sm font-medium text-slate-800">{doc.title}</td>
                          <td className="px-4 py-3 text-sm text-slate-600">{doc.team}</td>
                          <td className="px-4 py-3 text-sm text-slate-600">Step {doc.step}</td>
                          <td className="px-4 py-3 text-sm text-slate-600">{doc.author_name || '-'}</td>
                          <td className="px-4 py-3 text-sm text-slate-500">
                            {new Date(doc.created_at).toLocaleDateString('ko-KR')}
                          </td>
                          <td className="px-4 py-3">
                            <button
                              onClick={() => handleDeleteDoc(doc.id)}
                              className="text-red-600 hover:text-red-800 text-sm font-medium"
                            >
                              삭제
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                {allDocs.length === 0 && (
                  <div className="text-center py-8 text-slate-500">문서가 없습니다.</div>
                )}
              </div>
            )}

            {/* 통계 탭 */}
            {adminTab === 'stats' && (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="bg-white rounded-xl shadow p-6">
                  <h3 className="text-lg font-semibold text-slate-800 mb-4">역할별 사용자 분포</h3>
                  <div className="w-64 h-64 mx-auto">
                    <canvas ref={chartRef}></canvas>
                  </div>
                </div>
                <div className="bg-white rounded-xl shadow p-6">
                  <h3 className="text-lg font-semibold text-slate-800 mb-4">팀별 문서 현황</h3>
                  <div className="space-y-3">
                    {Object.entries(
                      allDocs.reduce((acc, doc) => {
                        acc[doc.team] = (acc[doc.team] || 0) + 1;
                        return acc;
                      }, {})
                    ).map(([team, count]) => (
                      <div key={team} className="flex items-center justify-between">
                        <span className="text-sm text-slate-600">{team}</span>
                        <div className="flex items-center gap-2">
                          <div className="w-32 bg-slate-200 rounded-full h-2">
                            <div
                              className="bg-indigo-600 h-2 rounded-full"
                              style={{ width: `${Math.min((count / allDocs.length) * 100, 100)}%` }}
                            ></div>
                          </div>
                          <span className="text-sm font-medium text-slate-800">{count}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* 역할 변경 모달 */}
            {showRoleModal && selectedUser && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div className="bg-white rounded-xl shadow-xl p-6 w-full max-w-md">
                  <h3 className="text-lg font-semibold text-slate-800 mb-4">역할 변경</h3>
                  <p className="text-sm text-slate-600 mb-4">
                    <strong>{selectedUser.name}</strong>님의 역할을 변경합니다.
                  </p>
                  <div className="grid grid-cols-3 gap-2 mb-6">
                    {['admin', 'mentor', 'mentee'].map(role => (
                      <button
                        key={role}
                        onClick={() => handleRoleChange(selectedUser.id, role)}
                        disabled={selectedUser.role === role}
                        className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
                          selectedUser.role === role
                            ? 'bg-slate-100 text-slate-400 cursor-not-allowed'
                            : role === 'admin'
                            ? 'bg-red-100 text-red-700 hover:bg-red-200'
                            : role === 'mentor'
                            ? 'bg-indigo-100 text-indigo-700 hover:bg-indigo-200'
                            : 'bg-green-100 text-green-700 hover:bg-green-200'
                        }`}
                      >
                        {role.toUpperCase()}
                      </button>
                    ))}
                  </div>
                  <button
                    onClick={() => { setShowRoleModal(false); setSelectedUser(null); }}
                    className="w-full px-4 py-2 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300"
                  >
                    취소
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      };

      const RoleSelectionPage = () => (
        <div className="flex flex-col items-center justify-center min-h-[calc(100vh-80px)] bg-slate-50 p-6">
          <div className="max-w-3xl w-full bg-white rounded-2xl shadow-xl p-8 text-center">
            <Icon name="user" className="w-16 h-16 text-indigo-600 mx-auto mb-4" />
            <h2 className="text-3xl font-bold text-slate-800 mb-2">환영합니다, {user?.name}!</h2>
            <p className="text-slate-500 mb-8">서비스 이용을 위해 역할을 선택해주세요.</p>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <button
                onClick={() => handleRoleSelect('mentor')}
                className="group flex flex-col items-center p-8 border-2 border-slate-200 rounded-xl hover:border-indigo-500 hover:bg-indigo-50 transition-all"
              >
                <div className="w-16 h-16 bg-indigo-100 rounded-full flex items-center justify-center mb-4 group-hover:scale-110 transition-transform">
                  <Icon name="upload" className="w-8 h-8 text-indigo-600" />
                </div>
                <h3 className="text-xl font-bold text-slate-700">멘토 (Mentor)</h3>
                <p className="text-slate-500 mt-2 text-sm">OJT 자료를 생성하고<br />교육 과정을 관리합니다.</p>
              </button>

              <button
                onClick={() => handleRoleSelect('mentee')}
                className="group flex flex-col items-center p-8 border-2 border-slate-200 rounded-xl hover:border-green-500 hover:bg-green-50 transition-all"
              >
                <div className="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mb-4 group-hover:scale-110 transition-transform">
                  <Icon name="book" className="w-8 h-8 text-green-600" />
                </div>
                <h3 className="text-xl font-bold text-slate-700">멘티 (Mentee)</h3>
                <p className="text-slate-500 mt-2 text-sm">공개된 교육 자료를 학습하고<br />퀴즈로 이해도를 검증합니다.</p>
              </button>
            </div>
          </div>
        </div>
      );

      const mentorDashboardContent = (
        <div className="max-w-6xl mx-auto p-6">
          <h2 className="text-2xl font-bold text-slate-800 flex items-center gap-2 mb-4">
            <Icon name="upload" className="w-6 h-6 text-indigo-600" />
            자료 생성 스튜디오
          </h2>

          {!aiStatus.online && (
            <div className="mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg flex items-start gap-3">
              <Icon name="alert" className="w-5 h-5 text-yellow-600 flex-shrink-0 mt-0.5" />
              <div>
                <p className="font-bold text-yellow-800">Gemini AI 연결 확인 중...</p>
                <p className="text-sm text-yellow-700 mt-1">
                  Google Gemini AI에 연결을 시도하고 있습니다.<br />
                  API 키가 올바른지 확인해주세요.
                </p>
              </div>
            </div>
          )}

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* 입력 폼 */}
            <div className="flex flex-col gap-4 bg-white p-6 rounded-xl shadow-sm border border-slate-200">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-xs font-bold text-slate-500 mb-1">대상 팀</label>
                  {!isCustomTeam ? (
                    <select
                      value={inputTeam}
                      onChange={(e) => { e.target.value === 'custom' ? (setIsCustomTeam(true), setInputTeam('')) : setInputTeam(e.target.value) }}
                      className="w-full p-2 border border-slate-300 rounded-lg text-sm bg-indigo-50"
                    >
                      {TEAMS.map(team => <option key={team} value={team}>{team}</option>)}
                      <option value="custom">+ 직접 입력</option>
                    </select>
                  ) : (
                    <div className="flex gap-2">
                      <input type="text" value={inputTeam} onChange={(e) => setInputTeam(e.target.value)} className="w-full p-2 border rounded-lg text-sm" autoFocus />
                      <button onClick={() => { setIsCustomTeam(false); setInputTeam(TEAMS[0]); }} className="p-2 bg-slate-200 rounded"><Icon name="refresh" className="w-4 h-4" /></button>
                    </div>
                  )}
                </div>
                <div>
                  <label className="block text-xs font-bold text-slate-500 mb-1">단계</label>
                  {!isCustomStep ? (
                    <select
                      value={inputStep}
                      onChange={(e) => { e.target.value === 'custom' ? (setIsCustomStep(true), setInputStep('')) : setInputStep(e.target.value) }}
                      className="w-full p-2 border border-slate-300 rounded-lg text-sm bg-indigo-50"
                    >
                      {STEPS.map(step => <option key={step} value={step}>Step {step}</option>)}
                      <option value="custom">+ 직접 입력</option>
                    </select>
                  ) : (
                    <div className="flex gap-2">
                      <input type="number" value={inputStep} onChange={(e) => setInputStep(e.target.value)} className="w-full p-2 border rounded-lg text-sm" autoFocus />
                      <button onClick={() => { setIsCustomStep(false); setInputStep(1); }} className="p-2 bg-slate-200 rounded"><Icon name="refresh" className="w-4 h-4" /></button>
                    </div>
                  )}
                </div>
              </div>
              <input type="text" placeholder="제목 (선택사항 - AI가 자동 생성)" className="w-full p-3 border rounded-lg" value={inputTitle} onChange={(e) => setInputTitle(e.target.value)} />

              {/* 자동 분할 옵션 */}
              <div className="flex items-center justify-between p-3 bg-slate-50 rounded-lg border border-slate-200">
                <div className="flex items-center gap-2">
                  <Icon name="split" className="w-5 h-5 text-indigo-600" />
                  <div>
                    <p className="text-sm font-medium text-slate-700">자동 스텝 분할</p>
                    <p className="text-xs text-slate-500">40분 이상 분량은 자동으로 여러 스텝으로 나눕니다</p>
                  </div>
                </div>
                <button
                  onClick={() => setAutoSplit(!autoSplit)}
                  className={`relative w-12 h-6 rounded-full transition-colors ${autoSplit ? 'bg-indigo-600' : 'bg-slate-300'}`}
                >
                  <span className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-transform ${autoSplit ? 'left-7' : 'left-1'}`} />
                </button>
              </div>

              {/* 예상 학습 시간 표시 */}
              {rawInput && (
                <div className={`flex items-center gap-3 p-3 rounded-lg border ${
                  estimatedTime > STEP_TIME_LIMIT
                    ? 'bg-amber-50 border-amber-200'
                    : 'bg-green-50 border-green-200'
                }`}>
                  <Icon name="clock" className={`w-5 h-5 ${estimatedTime > STEP_TIME_LIMIT ? 'text-amber-600' : 'text-green-600'}`} />
                  <div className="flex-1">
                    <p className={`text-sm font-medium ${estimatedTime > STEP_TIME_LIMIT ? 'text-amber-800' : 'text-green-800'}`}>
                      예상 학습 시간: 약 {estimatedTime}분
                    </p>
                    {requiredSteps > 1 && autoSplit && (
                      <p className="text-xs text-slate-600">
                        <Icon name="layers" className="w-3 h-3 inline mr-1" />
                        자동으로 {requiredSteps}개 스텝으로 분할됩니다 (스텝당 약 {Math.ceil(estimatedTime / requiredSteps)}분)
                      </p>
                    )}
                    {requiredSteps > 1 && !autoSplit && (
                      <p className="text-xs text-amber-600">
                        ⚠️ 40분 초과 분량입니다. 자동 분할을 권장합니다.
                      </p>
                    )}
                  </div>
                </div>
              )}

              {/* 입력 타입 선택 */}
              <div className="flex gap-2 border-b border-slate-200 pb-2">
                {INPUT_TYPES.map(type => (
                  <button
                    key={type.id}
                    onClick={() => setInputType(type.id)}
                    className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
                      inputType === type.id
                        ? 'bg-indigo-600 text-white'
                        : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
                    }`}
                  >
                    <Icon name={type.icon} className="w-4 h-4" />
                    {type.label}
                  </button>
                ))}
              </div>

              {/* 입력 타입별 UI */}
              {inputType === 'text' && (
                <div className="border border-slate-300 rounded-lg overflow-hidden">
                  <div ref={quillRef} />
                </div>
              )}

              {inputType === 'url' && (
                <div className="space-y-3">
                  <div className="flex gap-2">
                    <div className="flex-1 relative">
                      <Icon name="globe" className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-400" />
                      <input
                        type="url"
                        placeholder="https://example.com/article"
                        value={urlInput}
                        onChange={(e) => setUrlInput(e.target.value)}
                        className="w-full pl-10 p-3 border rounded-lg"
                      />
                    </div>
                  </div>
                  <p className="text-xs text-slate-500">
                    웹페이지의 텍스트 콘텐츠를 추출합니다. 구글 드라이브 공개 문서, 블로그, 뉴스 기사 등을 지원합니다.
                  </p>
                  {rawInput && inputType === 'url' && (
                    <div className="bg-slate-50 p-3 rounded-lg max-h-[150px] overflow-y-auto">
                      <p className="text-xs font-bold text-slate-500 mb-1">추출된 텍스트 미리보기:</p>
                      <p className="text-sm text-slate-600 whitespace-pre-wrap">{rawInput.substring(0, 500)}...</p>
                    </div>
                  )}
                </div>
              )}

              {inputType === 'pdf' && (
                <div className="space-y-3">
                  <label className="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed border-slate-300 rounded-lg cursor-pointer hover:bg-slate-50 transition-colors">
                    <div className="flex flex-col items-center justify-center pt-5 pb-6">
                      <Icon name="file" className="w-10 h-10 mb-3 text-slate-400" />
                      {pdfFile ? (
                        <p className="text-sm text-indigo-600 font-medium">{pdfFile.name}</p>
                      ) : (
                        <>
                          <p className="mb-2 text-sm text-slate-500">
                            <span className="font-semibold">클릭하여 PDF 선택</span>
                          </p>
                          <p className="text-xs text-slate-400">PDF 파일만 지원</p>
                        </>
                      )}
                    </div>
                    <input
                      type="file"
                      accept=".pdf"
                      className="hidden"
                      onChange={(e) => setPdfFile(e.target.files?.[0] || null)}
                    />
                  </label>
                  {pdfFile && (
                    <button
                      onClick={() => setPdfFile(null)}
                      className="text-sm text-red-500 hover:text-red-700"
                    >
                      파일 제거
                    </button>
                  )}
                  {rawInput && inputType === 'pdf' && (
                    <div className="bg-slate-50 p-3 rounded-lg max-h-[150px] overflow-y-auto">
                      <p className="text-xs font-bold text-slate-500 mb-1">추출된 텍스트 미리보기:</p>
                      <p className="text-sm text-slate-600 whitespace-pre-wrap">{rawInput.substring(0, 500)}...</p>
                    </div>
                  )}
                </div>
              )}

              <button
                onClick={handleGenerate}
                disabled={isProcessing || !aiStatus.online ||
                  (inputType === 'text' && !rawInput) ||
                  (inputType === 'url' && !urlInput) ||
                  (inputType === 'pdf' && !pdfFile)
                }
                className="w-full py-3 bg-indigo-600 text-white rounded-lg font-bold disabled:bg-slate-400 hover:bg-indigo-700 transition-colors"
              >
                {isProcessing ? processingStatus || "생성 중..." : `AI 자료 생성 (${GEMINI_MODEL})`}
              </button>
            </div>

            {/* 미리보기 */}
            <div className="bg-slate-50 p-6 rounded-xl shadow-inner border border-slate-200 overflow-y-auto max-h-[600px]">
              <div className="sticky top-0 bg-slate-50 pb-4 border-b border-slate-200 z-10">
                <div className="flex justify-between items-center">
                  <h3 className="font-semibold text-slate-700">
                    미리보기
                    {generatedDocs.length > 1 && (
                      <span className="ml-2 text-xs font-normal text-indigo-600">
                        ({generatedDocs.length}개 스텝 생성됨)
                      </span>
                    )}
                  </h3>
                  {(generatedDoc || generatedDocs.length > 0) && (
                    <button onClick={handleSaveToDB} className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg font-bold text-sm hover:bg-green-700">
                      <Icon name="save" className="w-4 h-4" />
                      {generatedDocs.length > 1 ? `${generatedDocs.length}개 모두 저장` : '저장'}
                    </button>
                  )}
                </div>

                {/* 여러 스텝인 경우 탭 UI */}
                {generatedDocs.length > 1 && (
                  <div className="flex gap-1 mt-3 overflow-x-auto pb-2">
                    {generatedDocs.map((doc, idx) => (
                      <button
                        key={idx}
                        onClick={() => setGeneratedDoc(doc)}
                        className={`px-3 py-1.5 text-xs font-medium rounded-lg whitespace-nowrap transition-colors ${
                          generatedDoc === doc
                            ? 'bg-indigo-600 text-white'
                            : 'bg-white text-slate-600 hover:bg-slate-100 border border-slate-200'
                        }`}
                      >
                        Step {doc.step}
                        {doc.estimatedMinutes && (
                          <span className="ml-1 opacity-70">({doc.estimatedMinutes}분)</span>
                        )}
                      </button>
                    ))}
                  </div>
                )}
              </div>

              <div className="mt-4">
                {generatedDoc ? (
                  <div>
                    <div className="flex items-center gap-2 mb-4">
                      <h1 className="text-xl font-bold">{generatedDoc.title}</h1>
                      {generatedDoc.estimatedMinutes && (
                        <span className="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full flex items-center gap-1">
                          <Icon name="clock" className="w-3 h-3" />
                          약 {generatedDoc.estimatedMinutes}분
                        </span>
                      )}
                    </div>
                    {generatedDoc.totalSteps > 1 && (
                      <p className="text-xs text-slate-500 mb-3">
                        📚 전체 {generatedDoc.totalSteps}개 스텝 중 {generatedDoc.stepIndex}번째
                      </p>
                    )}
                    {generatedDoc.sections?.map((s, i) => (
                      <div key={i} className="my-4 bg-white p-4 rounded shadow-sm">
                        <h3 className="font-bold text-indigo-700">{s.title}</h3>
                        <p className="text-sm text-slate-600 whitespace-pre-line mt-2">{s.content}</p>
                      </div>
                    ))}
                    <p className="text-sm text-slate-500 mt-4">퀴즈 {generatedDoc.quiz?.length || 0}문제 생성됨</p>
                  </div>
                ) : (
                  <div className="flex justify-center items-center h-64 text-slate-400">내용을 입력해주세요.</div>
                )}
              </div>
            </div>
          </div>

          {/* 내가 만든 자료 목록 */}
          {myDocs.length > 0 && (
            <div className="mt-8">
              <h3 className="text-lg font-bold text-slate-800 mb-4">내가 만든 자료 ({myDocs.length})</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {myDocs.map(doc => (
                  <div key={doc.id} className="bg-white p-4 rounded-xl shadow border flex justify-between items-start">
                    <div>
                      <span className="text-xs font-bold bg-indigo-100 text-indigo-700 px-2 py-1 rounded">{doc.team} - Step {doc.step}</span>
                      <h4 className="font-bold mt-2">{doc.title}</h4>
                    </div>
                    <button onClick={() => handleDeleteDoc(doc.id)} className="text-red-500 hover:text-red-700">
                      <Icon name="trash" className="w-4 h-4" />
                    </button>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      );

      // 멘티 문서 새로고침 함수
      const refreshPublicDocs = async () => {
        const allDocs = await dbGetAll("ojt_docs");
        allDocs.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
        setPublicDocs(allDocs);
      };

      // 멘티 리스트 계산값
      const availableTeams = Array.from(new Set(publicDocs.map(doc => doc.team).filter(Boolean)));
      const teamDocs = selectedTeam ? publicDocs.filter(doc => doc.team === selectedTeam).sort((a, b) => (a.step || 0) - (b.step || 0)) : [];

      // 멘티 리스트 JSX
      const menteeListContent = !selectedTeam ? (
        <div className="max-w-4xl mx-auto p-6">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold text-slate-800">학습할 팀을 선택하세요</h2>
            <button onClick={refreshPublicDocs} className="text-slate-500 hover:text-slate-700">
              <Icon name="refresh" className="w-5 h-5" />
            </button>
          </div>
          {availableTeams.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              {availableTeams.map(team => (
                <button key={team} onClick={() => setSelectedTeam(team)} className="bg-white p-6 rounded-xl shadow hover:shadow-lg border text-left transition-shadow">
                  <h3 className="font-bold text-lg text-slate-800">{team}</h3>
                  <p className="text-sm text-slate-500 mt-1">{publicDocs.filter(d => d.team === team).length}개 과정</p>
                </button>
              ))}
            </div>
          ) : (
            <div className="text-center py-16 text-slate-500">
              <Icon name="book" className="w-16 h-16 mx-auto mb-4 text-slate-300" />
              <p>아직 등록된 교육 자료가 없습니다.</p>
              <p className="text-sm mt-2">멘토가 자료를 등록하면 여기에 표시됩니다.</p>
            </div>
          )}
        </div>
      ) : (
        <div className="max-w-4xl mx-auto p-6">
          <button onClick={() => setSelectedTeam(null)} className="mb-4 text-slate-500 hover:text-slate-700">&larr; 뒤로가기</button>
          <h2 className="text-2xl font-bold mb-6">{selectedTeam} 로드맵</h2>
          <div className="space-y-4">
            {teamDocs.map((doc) => (
              <div key={doc.id} className="bg-white p-6 rounded-xl shadow border flex justify-between items-center">
                <div>
                  <span className="text-xs font-bold bg-indigo-100 text-indigo-700 px-2 py-1 rounded">Step {doc.step}</span>
                  <h3 className="font-bold text-lg mt-2">{doc.title}</h3>
                  <p className="text-xs text-slate-400 mt-1">작성자: {doc.author}</p>
                </div>
                <button onClick={() => handleSelectDoc(doc)} className="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700 transition-colors">학습하기</button>
              </div>
            ))}
          </div>
        </div>
      );

      // 멘티 학습 JSX
      const menteeStudyContent = selectedDoc ? (
        <div className="max-w-4xl mx-auto p-6">
          <button onClick={() => { setViewState('mentee_list'); setSelectedDoc(null); }} className="mb-4 text-slate-500 hover:text-slate-700">&larr; 목록으로</button>

          {!quizMode ? (
            <div className="bg-white p-8 rounded-xl shadow border">
              <div className="flex justify-between items-start mb-6">
                <div>
                  <span className="text-xs font-bold bg-indigo-100 text-indigo-700 px-2 py-1 rounded">{selectedDoc.team} - Step {selectedDoc.step}</span>
                  <h1 className="text-2xl font-bold mt-2">{selectedDoc.title}</h1>
                  <p className="text-sm text-slate-400 mt-1">작성자: {selectedDoc.author}</p>
                </div>
              </div>

              {selectedDoc.sections?.map((s, i) => (
                <div key={i} className="mb-6">
                  <h3 className="font-bold text-indigo-700 mb-2">{s.title}</h3>
                  <p className="whitespace-pre-line text-slate-700">{s.content}</p>
                </div>
              ))}

              <button onClick={startQuizSession} className="w-full py-4 bg-indigo-600 text-white rounded-lg font-bold mt-8 hover:bg-indigo-700 transition-colors">
                퀴즈 도전 ({selectedDoc.quiz?.length || 0}문제 중 4문제 출제)
              </button>
            </div>
          ) : (
            <div className="bg-white p-8 rounded-xl shadow border">
              {!quizSubmitted ? (
                <div>
                  <div className="flex justify-between mb-4">
                    <span className="font-bold text-indigo-600">Q{currentQuizIndex + 1} / 4</span>
                    <button onClick={() => setQuizMode(false)} className="text-slate-400 hover:text-slate-600"><Icon name="x" /></button>
                  </div>
                  <h3 className="text-xl font-bold mb-6">{activeQuizSet[currentQuizIndex]?.question}</h3>
                  <div className="space-y-2">
                    {activeQuizSet[currentQuizIndex]?.options?.map((opt, i) => (
                      <button
                        key={i}
                        onClick={() => handleAnswerSelect(currentQuizIndex, i)}
                        className={`w-full p-4 border rounded text-left transition-colors ${selectedAnswers[currentQuizIndex] === i ? 'bg-indigo-50 border-indigo-600' : 'hover:bg-slate-50'}`}
                      >
                        {opt}
                      </button>
                    ))}
                  </div>
                  <div className="flex justify-between mt-6">
                    <button
                      onClick={() => setCurrentQuizIndex(prev => Math.max(0, prev - 1))}
                      disabled={currentQuizIndex === 0}
                      className="text-slate-400 disabled:opacity-50"
                    >
                      이전
                    </button>
                    {currentQuizIndex < 3 ? (
                      <button onClick={() => setCurrentQuizIndex(prev => prev + 1)} className="bg-slate-800 text-white px-4 py-2 rounded hover:bg-slate-900">다음</button>
                    ) : (
                      <button onClick={submitQuiz} className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">제출</button>
                    )}
                  </div>
                </div>
              ) : (
                <div className="text-center py-8">
                  <h2 className="text-3xl font-bold mb-2">{passed ? "통과!" : "아쉬워요"}</h2>
                  <p className="text-xl mb-2 text-slate-600">{score} / 4 문제 정답</p>
                  <p className="text-slate-500 mb-6">{passed ? "훌륭합니다! 다음 단계로 넘어가세요." : `${QUIZ_PASS_THRESHOLD}문제 이상 맞춰야 통과입니다.`}</p>
                  <div className="flex gap-4 justify-center">
                    {!passed && (
                      <button onClick={startQuizSession} className="bg-indigo-600 text-white px-6 py-2 rounded hover:bg-indigo-700">다시 도전</button>
                    )}
                    <button onClick={() => { setViewState('mentee_list'); setSelectedDoc(null); setSelectedTeam(null); }} className="bg-slate-600 text-white px-6 py-2 rounded hover:bg-slate-700">목록으로</button>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      ) : null;

      // =========================================
      // Main Render
      // =========================================

      // 로딩 중 (초기 로드 또는 인증 처리 중)
      if (isLoadingAuth || viewState === 'loading') {
        return (
          <div className="flex h-screen items-center justify-center">
            <Icon name="refresh" className="w-8 h-8 animate-spin text-indigo-600" />
          </div>
        );
      }

      // 로그인 페이지
      if (viewState === 'login') {
        return <LoginPage />;
      }

      // 메인 앱 (로그인 후)
      return (
        <div className="min-h-screen bg-slate-50 font-sans text-slate-900">
          <Header />
          <main>
            {viewState === 'role_select' && <RoleSelectionPage />}
            {viewState === 'admin_dashboard' && <AdminDashboard />}
            {viewState === 'mentor_dashboard' && mentorDashboardContent}
            {viewState === 'mentee_list' && menteeListContent}
            {viewState === 'mentee_study' && menteeStudyContent}
          </main>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
