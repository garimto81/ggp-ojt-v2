<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OJT Master v2.6.4 - AI 기반 온보딩 교육 플랫폼</title>
  <!--
    CDN Script Loading Strategy:
    - Critical (sync): Tailwind, React, ReactDOM, Babel, Supabase, Dexie
    - Deferred: PDF.js, Quill, Chart.js, DOMPurify (used after initial render)
  -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Supabase Client (Core - needed for auth) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Dexie.js (Core - needed for local cache) -->
  <script src="https://unpkg.com/dexie@4/dist/dexie.min.js"></script>
  <!-- React Core (Critical for initial render) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- PDF.js (Deferred - only used for PDF upload) -->
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // PDF.js worker 설정 (defer된 스크립트 로드 후 설정)
    window.addEventListener('DOMContentLoaded', () => {
      if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
    });
  </script>
  <!-- Quill 2.0 Rich Text Editor (Deferred - only used in Mentor Dashboard) -->
  <link href="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.snow.css" rel="stylesheet" />
  <script defer src="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.js"></script>
  <!-- Chart.js (Deferred - only used in Admin Dashboard) -->
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- DOMPurify (Deferred - XSS 방어, used for content sanitization) -->
  <script defer src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
  <!-- React Hot Toast (Deferred - for user notifications) -->
  <script defer src="https://cdn.jsdelivr.net/npm/react-hot-toast@2.4.1/dist/index.umd.min.js"></script>
  <style>
    @keyframes spin { to { transform: rotate(360deg); } }
    .animate-spin { animation: spin 1s linear infinite; }
    /* Quill 에디터 스타일 커스터마이징 */
    .ql-container {
      font-size: 14px;
      min-height: 200px;
      border-bottom-left-radius: 0.5rem;
      border-bottom-right-radius: 0.5rem;
    }
    .ql-toolbar {
      border-top-left-radius: 0.5rem;
      border-top-right-radius: 0.5rem;
      background: #f8fafc;
    }
    .ql-editor {
      min-height: 180px;
    }
    .ql-editor.ql-blank::before {
      font-style: normal;
      color: #94a3b8;
    }
    /* Quill 에디터 이미지 스타일 */
    .ql-editor img {
      max-width: 100%;
      height: auto;
      border-radius: 0.5rem;
      margin: 0.5rem 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .ql-editor img:hover {
      transform: scale(1.01);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    /* 드래그 드롭 영역 하이라이트 */
    .ql-editor.drag-over {
      background-color: #e0e7ff;
      border: 2px dashed #6366f1;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo, useRef } = React;

    // 간단한 아이콘 컴포넌트 (SVG 기반)
    const Icon = ({ name, className = "w-5 h-5" }) => {
      const icons = {
        brain: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" /></svg>,
        book: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" /></svg>,
        upload: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>,
        save: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" /></svg>,
        refresh: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>,
        x: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>,
        logout: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" /></svg>,
        user: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" /></svg>,
        trash: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
        server: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" /></svg>,
        alert: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>,
        settings: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
        check: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" /></svg>,
        play: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        link: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" /></svg>,
        file: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg>,
        globe: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9" /></svg>,
        text: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>,
        split: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" /></svg>,
        clock: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
        layers: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>,
        edit: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>,
        eye: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>,
      };
      return icons[name] || null;
    };

    // =========================================
    // 설정 (Supabase)
    // =========================================
    const SUPABASE_URL = "https://cbvansmxutnogntbyswi.supabase.co";
    const SUPABASE_PUBLISHABLE_KEY = "sb_publishable_cPiRemnriBwn8rCT1JL9Qg_mjCeCBaI";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

    // =========================================
    // 설정 (Dexie.js - 로컬 캐시)
    // =========================================
    const CACHE_VERSION = 2; // 캐시 스키마 버전 (변경 시 증가)
    const CACHE_VERSION_KEY = 'ojt_cache_version';

    const localDb = new Dexie('OJTMasterCache');
    // Dexie 스키마 v2: 복합 인덱스 최적화
    // - [team+step]: 팀별 스텝 순서 조회
    // - [user_id+doc_id]: 사용자별 문서 학습 기록 조회
    localDb.version(2).stores({
      users: 'id, name, role, department',
      ojt_docs: 'id, team, step, author_id, updated_at, [team+step], [author_id+updated_at]',
      learning_records: 'id, user_id, doc_id, completed_at, [user_id+doc_id], [user_id+completed_at]',
      sync_queue: '++id, table, action, created_at'
    });

    // 온라인 상태 확인
    const isOnline = () => navigator.onLine;

    // =========================================
    // 보안 세션 스토리지 헬퍼
    // =========================================
    const SecureSession = {
      // 세션 만료 시간 (30분)
      EXPIRY_MS: 30 * 60 * 1000,

      // 허용된 키 목록 (화이트리스트)
      ALLOWED_KEYS: ['ojt_sessionMode'],

      // 허용된 값 목록 (키별)
      ALLOWED_VALUES: {
        'ojt_sessionMode': ['admin', 'mentor']
      },

      // 세션 데이터 저장 (만료 시간 포함)
      set(key, value) {
        if (!this.ALLOWED_KEYS.includes(key)) {
          console.warn(`SecureSession: 허용되지 않은 키 "${key}"`);
          return false;
        }
        if (this.ALLOWED_VALUES[key] && !this.ALLOWED_VALUES[key].includes(value)) {
          console.warn(`SecureSession: 허용되지 않은 값 "${value}" (키: ${key})`);
          return false;
        }
        const data = {
          value,
          timestamp: Date.now(),
          expiry: Date.now() + this.EXPIRY_MS
        };
        try {
          sessionStorage.setItem(key, JSON.stringify(data));
          return true;
        } catch (e) {
          console.error('SecureSession 저장 실패:', e);
          return false;
        }
      },

      // 세션 데이터 조회 (만료 체크)
      get(key) {
        if (!this.ALLOWED_KEYS.includes(key)) return null;
        try {
          const raw = sessionStorage.getItem(key);
          if (!raw) return null;

          const data = JSON.parse(raw);

          // 만료 체크
          if (Date.now() > data.expiry) {
            this.remove(key);
            console.log(`SecureSession: "${key}" 만료됨`);
            return null;
          }

          // 값 유효성 검증
          if (this.ALLOWED_VALUES[key] && !this.ALLOWED_VALUES[key].includes(data.value)) {
            this.remove(key);
            return null;
          }

          return data.value;
        } catch (e) {
          // JSON 파싱 실패 시 레거시 데이터 처리
          const legacy = sessionStorage.getItem(key);
          if (this.ALLOWED_VALUES[key]?.includes(legacy)) {
            // 레거시 값을 새 형식으로 마이그레이션
            this.set(key, legacy);
            return legacy;
          }
          this.remove(key);
          return null;
        }
      },

      // 세션 데이터 삭제
      remove(key) {
        sessionStorage.removeItem(key);
      },

      // 만료 시간 갱신 (활동 시)
      refresh(key) {
        const value = this.get(key);
        if (value) {
          this.set(key, value);
        }
      }
    };

    // =========================================
    // CSRF 방어: 삭제 확인 헬퍼
    // =========================================
    const confirmDeleteWithCSRF = (docTitle) => {
      // 1차 확인
      if (!confirm(`"${docTitle}" 문서를 정말로 삭제하시겠습니까?`)) {
        return false;
      }

      // 2차 확인: 제목 입력 요구
      const userInput = prompt(`삭제하려면 문서 제목을 정확히 입력하세요:\n"${docTitle}"`);
      if (userInput !== docTitle) {
        Toast.warning('제목이 일치하지 않습니다. 삭제가 취소되었습니다.');
        return false;
      }

      return true;
    };

    // Toast 헬퍼 (react-hot-toast 래퍼)
    // 라이브러리 로드 전에는 console.log로 폴백, 로드 후 실제 toast 사용
    const Toast = {
      _getToast() {
        return window.reactHotToast || (typeof toast !== 'undefined' ? toast : null);
      },
      success(message) {
        const t = this._getToast();
        if (t) t.success(message, { duration: 3000 });
        else console.log('[Toast Success]', message);
      },
      error(message) {
        const t = this._getToast();
        if (t) t.error(message, { duration: 5000 });
        else console.error('[Toast Error]', message);
      },
      info(message) {
        const t = this._getToast();
        if (t) t(message, { duration: 3000, icon: 'ℹ️' });
        else console.info('[Toast Info]', message);
      },
      warning(message) {
        const t = this._getToast();
        if (t) t(message, { duration: 4000, icon: '⚠️' });
        else console.warn('[Toast Warning]', message);
      },
      loading(message) {
        const t = this._getToast();
        if (t) return t.loading(message);
        console.log('[Toast Loading]', message);
        return null;
      },
      dismiss(toastId) {
        const t = this._getToast();
        if (t && toastId) t.dismiss(toastId);
      }
    };

    // XSS 방어: 텍스트 sanitize (HTML 태그 제거, 엔티티 이스케이프)
    const sanitizeText = (text) => {
      if (!text || typeof text !== 'string') return text;
      // DOMPurify가 로드되어 있으면 사용
      if (typeof DOMPurify !== 'undefined') {
        return DOMPurify.sanitize(text, { ALLOWED_TAGS: [], ALLOWED_ATTR: [] });
      }
      // fallback: 기본 HTML 엔티티 이스케이프
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    };

    // JSON 데이터 deep sanitize (sections, quiz 등)
    const sanitizeDocData = (doc) => {
      if (!doc) return doc;
      return {
        ...doc,
        title: sanitizeText(doc.title),
        team: sanitizeText(doc.team),
        sections: Array.isArray(doc.sections) ? doc.sections.map(s => ({
          ...s,
          title: sanitizeText(s.title),
          content: sanitizeText(s.content)
        })) : doc.sections,
        quiz: Array.isArray(doc.quiz) ? doc.quiz.map(q => ({
          ...q,
          question: sanitizeText(q.question),
          options: Array.isArray(q.options) ? q.options.map(opt => sanitizeText(opt)) : q.options
        })) : doc.quiz
      };
    };

    // 캐시 전체 클리어 (로그아웃 또는 버전 업그레이드 시 사용)
    const clearAllCache = async () => {
      try {
        await localDb.users.clear();
        await localDb.ojt_docs.clear();
        await localDb.learning_records.clear();
        await localDb.sync_queue.clear();
        console.log('All cache cleared successfully');
      } catch (e) {
        console.error('Cache clear error:', e);
      }
    };

    // 캐시 버전 체크 및 마이그레이션 (앱 시작 시 실행)
    const checkCacheVersion = async () => {
      const storedVersion = parseInt(localStorage.getItem(CACHE_VERSION_KEY) || '0', 10);

      if (storedVersion < CACHE_VERSION) {
        console.log(`Cache version upgrade: ${storedVersion} → ${CACHE_VERSION}`);
        await clearAllCache();
        localStorage.setItem(CACHE_VERSION_KEY, String(CACHE_VERSION));
        console.log('Cache migration completed');
      }
    };

    // 앱 시작 시 캐시 버전 체크 실행
    checkCacheVersion();

    // =========================================
    // 설정 (AI - Google Gemini API)
    // ⚠️ 보안 주의: 프로덕션 환경에서는 Supabase Edge Function으로 프록시 권장
    // 현재 키는 HTTP Referer 제한 설정됨 (ggp-ojt-v2.vercel.app만 허용)
    // =========================================
    const GEMINI_API_KEY = "AIzaSyCvH1uc1OJ7EHmiWfsjbKVFH-X8KuvXH2I"; // Google AI Studio에서 발급
    const GEMINI_MODEL = "gemini-2.0-flash-exp"; // 무료 티어: gemini-2.0-flash-exp (권장)
    const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models";

    // =========================================
    // 설정 (Cloudflare R2 이미지 스토리지)
    // ⚠️ Worker URL은 배포 후 실제 URL로 변경 필요
    // =========================================
    const R2_WORKER_URL = "https://ojt-r2-upload.garimto81.workers.dev"; // Cloudflare Worker URL
    const R2_MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    const R2_ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

    // R2 이미지 업로드 함수
    async function uploadImageToR2(file) {
      // 파일 유효성 검사
      if (!file) {
        throw new Error('파일이 선택되지 않았습니다');
      }

      if (!R2_ALLOWED_TYPES.includes(file.type)) {
        throw new Error('허용되지 않는 파일 형식입니다. (JPG, PNG, GIF, WebP만 지원)');
      }

      if (file.size > R2_MAX_FILE_SIZE) {
        throw new Error('파일 크기는 10MB를 초과할 수 없습니다');
      }

      try {
        // 1. Worker에 업로드 URL 요청
        const prepareRes = await fetch(R2_WORKER_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filename: file.name,
            contentType: file.type,
            fileSize: file.size
          })
        });

        if (!prepareRes.ok) {
          const error = await prepareRes.json();
          throw new Error(error.error || '업로드 준비 실패');
        }

        const { uploadUrl, key, publicUrl } = await prepareRes.json();

        // 2. 파일 업로드
        const uploadRes = await fetch(`${R2_WORKER_URL}/upload`, {
          method: 'PUT',
          headers: {
            'Content-Type': file.type,
            'X-Upload-Key': key
          },
          body: file
        });

        if (!uploadRes.ok) {
          const error = await uploadRes.json();
          throw new Error(error.error || '파일 업로드 실패');
        }

        const result = await uploadRes.json();
        console.log('Image uploaded to R2:', result.url);
        return result.url;

      } catch (error) {
        console.error('R2 upload error:', error);
        throw error;
      }
    }

    // R2 이미지 삭제 함수
    async function deleteImageFromR2(imageUrl) {
      try {
        // URL에서 key 추출
        const urlParts = imageUrl.split('/');
        const key = urlParts.slice(-2).join('/'); // uploads/timestamp-random.ext

        const response = await fetch(R2_WORKER_URL, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ key })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || '이미지 삭제 실패');
        }

        console.log('Image deleted from R2:', key);
        return true;
      } catch (error) {
        console.error('R2 delete error:', error);
        return false;
      }
    }

    // =========================================
    // 앱 설정 상수 (매직 넘버 통합 관리)
    // =========================================
    const CONFIG = {
      // 학습 관련
      STEP_TIME_LIMIT: 40,          // 분 (한 스텝당 최대 학습 시간)
      CHARS_PER_MINUTE: 500,        // 분당 읽기 속도 (한국어 기준)
      MAX_URL_EXTRACT_CHARS: 15000, // URL 텍스트 추출 최대 문자
      QUIZ_PASS_THRESHOLD: 3,       // 퀴즈 통과 기준 (4문제 중)
      QUIZ_QUESTIONS_PER_TEST: 4,   // 테스트당 퀴즈 문제 수
      QUIZ_TOTAL_POOL: 20,          // 퀴즈 풀 전체 문제 수
      // AI 설정
      AI_RETRY_TIMEOUT: 30000,      // AI 상태 체크 간격 (ms)
      AI_TEMPERATURE: 0.3,          // Gemini 온도 설정
      AI_MAX_TOKENS: 8192,          // Gemini 최대 토큰
      // 보안: 허용된 OAuth Redirect 도메인
      ALLOWED_ORIGINS: [
        'https://ggp-ojt-v2.vercel.app',
        'http://localhost:3000',
        'http://localhost:51544',
        'http://127.0.0.1:3000',
      ],
    };
    // 계산된 상수
    CONFIG.MAX_CHARS_PER_STEP = CONFIG.STEP_TIME_LIMIT * CONFIG.CHARS_PER_MINUTE; // 20,000자

    // =========================================
    // 스텝 분할 설정 (CONFIG 참조)
    // =========================================
    // 하위 호환성을 위한 별칭
    const STEP_TIME_LIMIT = CONFIG.STEP_TIME_LIMIT;
    const CHARS_PER_MINUTE = CONFIG.CHARS_PER_MINUTE;
    const MAX_CHARS_PER_STEP = CONFIG.MAX_CHARS_PER_STEP;

    // 콘텐츠 분량 추정 함수
    function estimateReadingTime(text) {
      if (!text) return 0;
      const charCount = text.length;
      return Math.ceil(charCount / CONFIG.CHARS_PER_MINUTE);
    }

    // 필요한 스텝 수 계산
    function calculateRequiredSteps(text) {
      if (!text) return 1;
      const charCount = text.length;
      return Math.max(1, Math.ceil(charCount / CONFIG.MAX_CHARS_PER_STEP));
    }

    // 텍스트를 스텝별로 분할 (의미 단위로 분할 시도)
    function splitContentForSteps(text, numSteps) {
      if (!text || numSteps <= 1) return [text || ''];

      const segments = [];
      const avgLength = Math.ceil(text.length / numSteps);

      // 줄바꿈, 문단, 또는 문장 단위로 분할 시도
      const paragraphs = text.split(/\n\n+/).filter(p => p.trim().length > 0);

      if (paragraphs.length >= numSteps) {
        // 문단이 충분하면 문단 단위로 분배
        const perStep = Math.ceil(paragraphs.length / numSteps);
        for (let i = 0; i < numSteps; i++) {
          const start = i * perStep;
          const end = Math.min(start + perStep, paragraphs.length);
          segments.push(paragraphs.slice(start, end).join('\n\n'));
        }
      } else {
        // 문단이 부족하면 글자 수 기준으로 분할
        let currentPos = 0;
        for (let i = 0; i < numSteps; i++) {
          const targetEnd = currentPos + avgLength;
          let actualEnd = targetEnd;

          // 문장 끝(.!?)을 찾아서 자연스럽게 분할
          if (i < numSteps - 1 && targetEnd < text.length) {
            const searchRange = text.substring(targetEnd - 100, targetEnd + 100);
            const sentenceEnd = searchRange.search(/[.!?。]\s/);
            if (sentenceEnd !== -1) {
              actualEnd = targetEnd - 100 + sentenceEnd + 2;
            }
          } else {
            actualEnd = text.length;
          }

          segments.push(text.substring(currentPos, actualEnd).trim());
          currentPos = actualEnd;
        }
      }

      // 빈 세그먼트 필터링 후 개수 재검증
      let validSegments = segments.filter(s => s.length > 0);

      // 세그먼트 수가 요청된 스텝 수보다 적으면 병합/경고
      if (validSegments.length < numSteps) {
        console.warn(`스텝 분할 경고: 요청 ${numSteps}개, 실제 ${validSegments.length}개`);
        // 최소 1개는 보장
        if (validSegments.length === 0) {
          validSegments = [text];
        }
      }

      // 세그먼트 수가 요청된 스텝 수보다 많으면 마지막 세그먼트에 병합
      while (validSegments.length > numSteps && validSegments.length > 1) {
        const last = validSegments.pop();
        validSegments[validSegments.length - 1] += '\n\n' + last;
      }

      return validSegments;
    }

    // =========================================
    // DB 헬퍼 (Dexie 캐시 + Supabase 동기화)
    // =========================================

    // Sync Queue 최대 재시도 횟수
    const MAX_SYNC_RETRIES = 3;

    // 동기화 중복 실행 방지 플래그
    let isSyncQueueProcessing = false;

    // 오프라인 큐에 작업 추가
    const addToSyncQueue = async (table, action, data) => {
      await localDb.sync_queue.add({
        table,
        action,
        data,
        retryCount: 0,
        created_at: new Date().toISOString()
      });
    };

    // 오프라인 큐 처리 (온라인 복귀 시)
    const processSyncQueue = async () => {
      // 중복 실행 방지
      if (isSyncQueueProcessing) {
        console.log('Sync queue already processing, skipping...');
        return;
      }

      isSyncQueueProcessing = true;

      try {
        const queue = await localDb.sync_queue.toArray();

        for (const item of queue) {
          try {
            if (item.action === 'upsert') {
              await supabase.from(item.table).upsert(item.data);
            } else if (item.action === 'insert') {
              await supabase.from(item.table).insert(item.data);
            } else if (item.action === 'delete') {
              await supabase.from(item.table).delete().eq('id', item.data.id);
            }
            // 성공하면 큐에서 제거
            await localDb.sync_queue.delete(item.id);
          } catch (e) {
            console.error('Sync queue processing failed:', e);
            // 재시도 횟수 증가
            const retryCount = (item.retryCount || 0) + 1;
            if (retryCount >= MAX_SYNC_RETRIES) {
              // 최대 재시도 초과 시 큐에서 제거 (데이터 손실 방지 로그)
              console.error(`Sync item permanently failed after ${MAX_SYNC_RETRIES} retries:`, item);
              await localDb.sync_queue.delete(item.id);
            } else {
              // 재시도 횟수 업데이트
              await localDb.sync_queue.update(item.id, { retryCount });
            }
          }
        }
      } finally {
        isSyncQueueProcessing = false;
      }
    };

    // 온라인 상태 변경 감지
    window.addEventListener('online', () => {
      console.log('Online - Processing sync queue...');
      processSyncQueue();
    });

    // 단일 조회 (캐시 우선, 온라인 시 동기화)
    // 타임아웃 유틸리티 함수
    const withTimeout = (promise, ms) => {
      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error(`Timeout after ${ms}ms`)), ms)
      );
      return Promise.race([promise, timeout]);
    };

    const SUPABASE_QUERY_TIMEOUT = 10000; // 10초 타임아웃

    const dbGet = async (storeName, key) => {
      // 1. 로컬 캐시 먼저 확인
      let cached = await localDb[storeName].get(key);
      console.log(`dbGet(${storeName}, ${key}): cached =`, cached);

      // 2. 온라인이면 Supabase에서 최신 데이터 가져오기 (타임아웃 적용)
      if (isOnline()) {
        try {
          const { data, error } = await withTimeout(
            supabase
              .from(storeName)
              .select("*")
              .eq("id", key)
              .maybeSingle(),
            SUPABASE_QUERY_TIMEOUT
          );

          console.log(`dbGet(${storeName}, ${key}): supabase response`, { data, error });

          if (error) {
            console.error(`dbGet Supabase error for ${storeName}:`, error.message, error.code);
            // Supabase 에러 발생 시 캐시 데이터 반환 (캐시 있으면 사용)
            return cached;
          }

          if (data) {
            // 캐시 업데이트
            await localDb[storeName].put(data);
            cached = data;
          }
        } catch (e) {
          console.error("dbGet sync error:", e.message);
          // 타임아웃 또는 에러 발생 시에도 캐시 데이터 반환
        }
      }

      return cached;
    };

    // 전체 조회 (캐시 먼저 반환, 백그라운드 동기화)
    const dbGetAll = async (storeName, filters = {}) => {
      // 1. 로컬 캐시에서 먼저 조회
      let cached = [];

      try {
        if (storeName === "ojt_docs") {
          let collection = localDb.ojt_docs.toCollection();
          if (filters.team) {
            collection = localDb.ojt_docs.where('team').equals(filters.team);
          }
          cached = await collection.reverse().sortBy('updated_at');
          if (filters.authorId) {
            cached = cached.filter(doc => doc.author_id === filters.authorId);
          }
        } else if (storeName === "learning_records") {
          if (filters.userId) {
            cached = await localDb.learning_records.where('user_id').equals(filters.userId).toArray();
          } else {
            cached = await localDb.learning_records.toArray();
          }
        } else {
          cached = await localDb[storeName].toArray();
        }
      } catch (e) {
        console.error("Local cache read error:", e);
      }

      // 2. 온라인이면 백그라운드에서 Supabase 동기화
      if (isOnline()) {
        (async () => {
          try {
            let query = supabase.from(storeName).select("*");

            if (storeName === "ojt_docs") {
              query = query.order("created_at", { ascending: false });
              if (filters.team) query = query.eq("team", filters.team);
              if (filters.authorId) query = query.eq("author_id", filters.authorId);
            } else if (storeName === "learning_records") {
              if (filters.userId) query = query.eq("user_id", filters.userId);
            }

            const { data, error } = await query;

            if (data && !error) {
              // 캐시 동기화 (삭제된 데이터 정리)
              const remoteIds = new Set(data.map(item => item.id));

              if (!filters.team && !filters.authorId && !filters.userId) {
                // 필터 없는 전체 조회: 캐시 완전 교체
                await localDb[storeName].clear();
              } else {
                // 필터 있는 조회: 해당 조건의 캐시 항목 중 원격에 없는 것만 삭제
                const localItems = await localDb[storeName].toArray();
                const itemsToDelete = localItems.filter(item => {
                  // 필터 조건에 맞는 항목 중 원격에 없는 것
                  let matchesFilter = true;
                  if (filters.team && item.team !== filters.team) matchesFilter = false;
                  if (filters.authorId && item.author_id !== filters.authorId) matchesFilter = false;
                  if (filters.userId && item.user_id !== filters.userId) matchesFilter = false;
                  return matchesFilter && !remoteIds.has(item.id);
                });

                // 삭제된 항목들 제거
                if (itemsToDelete.length > 0) {
                  console.log(`Removing ${itemsToDelete.length} deleted items from cache`);
                  await Promise.all(itemsToDelete.map(item => localDb[storeName].delete(item.id)));
                }
              }

              // 원격 데이터로 캐시 업데이트
              await localDb[storeName].bulkPut(data);
            }
          } catch (e) {
            console.error("Background sync error:", e);
          }
        })();
      }

      // ojt_docs인 경우 XSS 방어를 위해 sanitize 적용
      if (storeName === "ojt_docs") {
        return cached.map(doc => sanitizeDocData(doc));
      }

      return cached;
    };

    // 생성/수정 (로컬 먼저, 온라인 시 동기화)
    const dbPut = async (storeName, data) => {
      const now = new Date().toISOString();
      let localData = { ...data, updated_at: now };

      // Supabase 필드명으로 변환
      if (storeName === "users") {
        localData = {
          id: data.id,
          name: data.name,
          role: data.role,
          department: data.department || null,
          updated_at: now
        };
      } else if (storeName === "ojt_docs") {
        localData = {
          id: data.id,
          title: data.title,
          team: data.team,
          step: data.step,
          sections: data.sections,
          quiz: data.quiz,
          author_id: data.authorId,
          author_name: data.author,
          estimated_minutes: data.estimatedMinutes || 30,
          // Source tracking fields
          source_type: data.source_type || 'manual',
          source_url: data.source_url || null,
          source_file: data.source_file || null,
          updated_at: now
        };
      }

      // 1. 로컬 캐시에 즉시 저장
      await localDb[storeName].put(localData);

      // 2. 온라인이면 Supabase에 동기화
      if (isOnline()) {
        try {
          if (storeName === "users") {
            // users는 insert/update 분리
            let { error } = await supabase.from("users").insert(localData).select().single();
            if (error && error.code === "23505") {
              await supabase.from("users")
                .update({ name: localData.name, role: localData.role, department: localData.department })
                .eq("id", localData.id);
            }
          } else {
            await supabase.from(storeName).upsert(localData);
          }
        } catch (e) {
          console.error("dbPut sync error:", e);
          await addToSyncQueue(storeName, 'upsert', localData);
        }
      } else {
        await addToSyncQueue(storeName, 'upsert', localData);
      }

      return localData;
    };

    // 새 데이터 추가 (로컬 먼저, 온라인 시 동기화)
    const dbAdd = async (storeName, data) => {
      const now = new Date().toISOString();
      const newId = crypto.randomUUID();
      let localData = { ...data, id: newId, created_at: now, updated_at: now };

      // Supabase 필드명으로 변환
      if (storeName === "ojt_docs") {
        localData = {
          id: newId,
          title: data.title,
          team: data.team,
          step: data.step,
          sections: data.sections,
          quiz: data.quiz,
          author_id: data.authorId,
          author_name: data.author,
          estimated_minutes: data.estimatedMinutes || 30,
          // Source tracking fields
          source_type: data.source_type || 'manual',
          source_url: data.source_url || null,
          source_file: data.source_file || null,
          created_at: now,
          updated_at: now
        };
      } else if (storeName === "learning_records") {
        localData = {
          id: newId,
          user_id: data.userId,
          doc_id: data.docId,
          score: data.score,
          total_questions: data.totalQuestions || 4,
          passed: data.passed,
          completed_at: now
        };
      }

      // 1. 로컬 캐시에 즉시 저장
      await localDb[storeName].add(localData);

      // 2. 온라인이면 Supabase에 동기화
      if (isOnline()) {
        try {
          await supabase.from(storeName).insert(localData);
        } catch (e) {
          console.error("dbAdd sync error:", e);
          await addToSyncQueue(storeName, 'insert', localData);
        }
      } else {
        await addToSyncQueue(storeName, 'insert', localData);
      }

      return newId;
    };

    // 삭제 (로컬 먼저, 온라인 시 동기화)
    const dbDelete = async (storeName, key) => {
      // 1. 로컬 캐시에서 삭제
      await localDb[storeName].delete(key);

      // 2. 온라인이면 Supabase에서 삭제
      if (isOnline()) {
        try {
          await supabase.from(storeName).delete().eq("id", key);
        } catch (e) {
          console.error("dbDelete sync error:", e);
          await addToSyncQueue(storeName, 'delete', { id: key });
        }
      } else {
        await addToSyncQueue(storeName, 'delete', { id: key });
      }

      return true;
    };

    // =========================================
    // Constants (팀, 스텝, 입력 타입)
    // =========================================
    const TEAMS = ["공통 (Common)", "개발팀 (Dev)", "디자인팀 (Design)", "기획팀 (PM)", "인사팀 (HR)", "영업팀 (Sales)"];
    const STEPS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const QUIZ_PASS_THRESHOLD = CONFIG.QUIZ_PASS_THRESHOLD; // 하위 호환성
    const INPUT_TYPES = [
      { id: 'text', label: '직접 입력', icon: 'text', desc: '텍스트를 직접 작성' },
      { id: 'url', label: 'URL', icon: 'globe', desc: '웹페이지 텍스트 추출' },
      { id: 'pdf', label: 'PDF', icon: 'file', desc: 'PDF 파일에서 추출' },
    ];

    // =========================================
    // Content Extraction Functions
    // =========================================

    // PDF 텍스트 추출
    async function extractPdfText(file, setProgress) {
      setProgress && setProgress("PDF 로딩 중...");
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

      let fullText = '';
      const numPages = pdf.numPages;

      for (let i = 1; i <= numPages; i++) {
        setProgress && setProgress(`PDF 페이지 ${i}/${numPages} 처리 중...`);
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map(item => item.str).join(' ');
        fullText += pageText + '\n\n';
      }

      return fullText.trim();
    }

    // SSRF 방어: URL 검증 함수
    function validateUrlForSSRF(urlString) {
      const BLOCKED_HOSTS = [
        'localhost', '127.0.0.1', '0.0.0.0', '::1',
        '169.254.169.254', // AWS metadata
        'metadata.google.internal', // GCP metadata
        '100.100.100.200' // Alibaba Cloud metadata
      ];

      try {
        const url = new URL(urlString);

        // 프로토콜 검증 (http/https만 허용)
        if (!['http:', 'https:'].includes(url.protocol)) {
          throw new Error('http 또는 https 프로토콜만 허용됩니다.');
        }

        // 내부 호스트 차단
        const hostname = url.hostname.toLowerCase();
        if (BLOCKED_HOSTS.some(blocked => hostname === blocked || hostname.endsWith('.' + blocked))) {
          throw new Error('내부 네트워크 주소는 허용되지 않습니다.');
        }

        // Private IP 범위 차단 (10.x.x.x, 172.16-31.x.x, 192.168.x.x)
        const ipMatch = hostname.match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
        if (ipMatch) {
          const [_, a, b] = ipMatch.map(Number);
          if (a === 10 || (a === 172 && b >= 16 && b <= 31) || (a === 192 && b === 168) || a === 127) {
            throw new Error('Private IP 주소는 허용되지 않습니다.');
          }
        }

        return true;
      } catch (e) {
        if (e.message.includes('Invalid URL')) {
          throw new Error('유효하지 않은 URL 형식입니다.');
        }
        throw e;
      }
    }

    // URL 텍스트 추출 (CORS 프록시 사용)
    async function extractUrlText(url, setProgress) {
      setProgress && setProgress("URL 검증 중...");

      // SSRF 방어: URL 검증
      validateUrlForSSRF(url);

      setProgress && setProgress("웹페이지 가져오는 중...");

      // 여러 CORS 프록시 시도
      const corsProxies = [
        `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
        `https://corsproxy.io/?${encodeURIComponent(url)}`,
      ];

      let html = null;
      for (const proxyUrl of corsProxies) {
        try {
          const response = await fetch(proxyUrl);
          if (response.ok) {
            html = await response.text();
            break;
          }
        } catch (e) {
          console.log("Proxy failed:", proxyUrl);
        }
      }

      if (!html) {
        throw new Error("웹페이지를 가져올 수 없습니다. URL을 확인해주세요.");
      }

      setProgress && setProgress("텍스트 추출 중...");

      // HTML을 텍스트로 변환 (간단한 파싱)
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      // 스크립트, 스타일 태그 제거
      const removeElements = doc.querySelectorAll('script, style, nav, footer, header, aside, noscript');
      removeElements.forEach(el => el.remove());

      // 본문 텍스트 추출 (우선순위: article > main > body)
      const article = doc.querySelector('article');
      const main = doc.querySelector('main');
      const body = doc.body;

      const targetElement = article || main || body;
      let text = targetElement ? targetElement.innerText : '';

      // 중복 공백/줄바꿈 정리
      text = text.replace(/\s+/g, ' ').replace(/\n\s*\n/g, '\n\n').trim();

      // 최대 15000자로 제한 (truncation 정보 포함)
      const originalLength = text.length;
      const wasTruncated = text.length > CONFIG.MAX_URL_EXTRACT_CHARS;
      if (wasTruncated) {
        text = text.substring(0, CONFIG.MAX_URL_EXTRACT_CHARS) + '...\n\n[내용이 너무 길어 일부만 추출되었습니다]';
      }

      // 객체로 반환 (truncation 정보 포함)
      return {
        text,
        wasTruncated,
        originalLength,
        extractedLength: wasTruncated ? CONFIG.MAX_URL_EXTRACT_CHARS : originalLength
      };
    }

    // =========================================
    // AI Logic (Google Gemini API)
    // =========================================

    // Gemini API 상태 체크
    async function checkAIStatus() {
      // API 키가 설정되어 있으면 온라인으로 간주 (실제 호출 시 검증됨)
      if (GEMINI_API_KEY) {
        return {
          online: true,
          provider: 'gemini',
          model: GEMINI_MODEL
        };
      }

      return {
        online: false,
        provider: null,
        model: null
      };
    }

    // Gemini AI 상태 체크 함수 별칭 (기존 코드 호환성)
    const checkGeminiStatus = checkAIStatus;

    // =========================================
    // AI 응답 파싱 헬퍼 함수들
    // =========================================

    // JSON 문자열 정리 (AI 응답의 불완전한 JSON 처리)
    function cleanJsonString(str) {
      // 1. 제어 문자 제거 (탭과 줄바꿈은 유지)
      str = str.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');

      // 2. JSON 문자열 내부의 실제 줄바꿈을 \\n으로 변환
      str = str.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (match) => {
        return match
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/\t/g, '\\t');
      });

      // 3. JSON 구조 밖의 줄바꿈 제거
      str = str.replace(/\n/g, ' ').replace(/\r/g, '');

      // 4. 잘못된 유니코드 이스케이프 수정
      str = str.replace(/\\u(?![0-9a-fA-F]{4})/g, '\\\\u');

      return str;
    }

    // AI 응답에서 JSON 추출 (정규식 폴백 포함)
    function parseAIResponseToJSON(responseText) {
      // 마크다운 코드블록 제거
      let cleanedResponse = responseText
        .replace(/```json\s*/gi, '')
        .replace(/```\s*/g, '')
        .trim();

      // JSON 부분 추출
      const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error("JSON 형식 응답을 받지 못했습니다.");
      }

      const jsonStr = jsonMatch[0];

      // 1차 시도: 정리 후 파싱
      try {
        return JSON.parse(cleanJsonString(jsonStr));
      } catch (parseError) {
        console.warn("JSON 파싱 실패, regex fallback 시도:", parseError.message);
      }

      // 2차 시도: 정규식으로 필드 추출
      const titleMatch = cleanedResponse.match(/"title"\s*:\s*"([^"]+)"/);
      const title = titleMatch ? titleMatch[1] : "생성된 문서";

      const sections = [];
      const sectionRegex = /\{\s*"title"\s*:\s*"([^"]+)"\s*,\s*"content"\s*:\s*"([^"]+)"\s*\}/g;
      const sectionsArrayMatch = cleanedResponse.match(/"sections"\s*:\s*\[([\s\S]*?)\]/);
      if (sectionsArrayMatch) {
        let sectionMatch;
        while ((sectionMatch = sectionRegex.exec(sectionsArrayMatch[1])) !== null) {
          sections.push({ title: sectionMatch[1], content: sectionMatch[2] });
        }
      }

      const quiz = [];
      const quizArrayMatch = cleanedResponse.match(/"quiz"\s*:\s*\[([\s\S]*?)\]/);
      if (quizArrayMatch) {
        const quizRegex = /\{\s*"id"\s*:\s*(\d+)\s*,\s*"question"\s*:\s*"([^"]+)"\s*,\s*"options"\s*:\s*\[([^\]]+)\]\s*,\s*"answer"\s*:\s*(\d+)\s*\}/g;
        let quizMatch;
        while ((quizMatch = quizRegex.exec(quizArrayMatch[1])) !== null) {
          const options = quizMatch[3].match(/"([^"]+)"/g)?.map(o => o.replace(/"/g, '')) || [];
          quiz.push({
            id: parseInt(quizMatch[1]),
            question: quizMatch[2],
            options,
            answer: parseInt(quizMatch[4])
          });
        }
      }

      if (sections.length === 0 && quiz.length === 0) {
        throw new Error('AI 응답을 파싱하지 못했습니다. 다시 시도해주세요.');
      }

      console.warn("regex fallback으로 파싱 완료");
      return {
        title,
        sections: sections.length > 0 ? sections : [{ title: "내용", content: "AI 응답에서 섹션을 파싱하지 못했습니다." }],
        quiz
      };
    }

    // OJT 결과 검증 및 퀴즈 보충
    function validateAndFillOJTResult(result, docTitle) {
      const validationErrors = [];

      // 섹션 검증
      if (!Array.isArray(result.sections) || result.sections.length === 0) {
        validationErrors.push('섹션이 생성되지 않았습니다');
        result.sections = [{ title: "내용 없음", content: "AI가 섹션을 생성하지 못했습니다." }];
      }

      // 퀴즈 배열 검증
      if (!Array.isArray(result.quiz)) {
        result.quiz = [];
      }

      const originalQuizCount = result.quiz.length;

      // 퀴즈 수 확인
      if (originalQuizCount < CONFIG.QUIZ_QUESTIONS_PER_TEST) {
        validationErrors.push(`퀴즈가 ${originalQuizCount}개만 생성됨 (최소 ${CONFIG.QUIZ_QUESTIONS_PER_TEST}개 필요)`);
      }

      // 20개 미만이면 더미로 채우기
      while (result.quiz.length < CONFIG.QUIZ_TOTAL_POOL) {
        const quizNum = result.quiz.length + 1;
        result.quiz.push({
          id: quizNum,
          question: `[자동 생성] ${docTitle || '문서'} 복습 문제 ${quizNum}`,
          options: [
            "본문에서 설명한 핵심 내용을 선택하세요",
            "이 선지는 오답입니다 (A)",
            "이 선지는 오답입니다 (B)",
            "이 선지는 오답입니다 (C)"
          ],
          answer: 0,
          isAutoGenerated: true
        });
      }

      // 메타데이터 추가
      result._parseInfo = {
        originalQuizCount,
        autoGeneratedQuizCount: CONFIG.QUIZ_TOTAL_POOL - originalQuizCount,
        validationErrors,
        parsedAt: new Date().toISOString()
      };

      if (validationErrors.length > 0) {
        console.warn('AI 파싱 경고:', validationErrors.join(', '));
      }

      return result;
    }

    // =========================================
    // AI 콘텐츠 생성 메인 함수
    // =========================================
    async function generateOJTContent(rawText, team, step, setProgress, totalSteps = 1) {
      const stepInfo = totalSteps > 1 ? ` (총 ${totalSteps}개 스텝 중 ${step}번째 스텝)` : '';
      const prompt = `/no_think
당신은 10년 경력의 기업 교육 설계 전문가입니다. 비정형 업무 메모를 체계적인 신입사원 OJT 자료로 변환하는 것이 전문 분야입니다.

## 작업 요청
아래 [입력 텍스트]를 ${team} 부서 신입사원을 위한 Step ${step}${stepInfo} OJT 교육 자료로 변환해주세요.

## 콘텐츠 작성 가이드라인

### 1. 섹션 구성 원칙 (3-5개 섹션)
각 섹션은 다음 구조를 따르세요:
- **학습 목표**: 이 섹션을 통해 무엇을 배울 수 있는지 한 문장으로
- **핵심 내용**: 신입사원이 반드시 알아야 할 내용 (구체적 절차, 규칙, 용어 설명)
- **실무 예시**: 실제 업무에서 어떻게 적용되는지 구체적 상황 예시
- **주의사항**: 신입사원이 자주 실수하는 부분, 주의할 점

### 2. 글쓰기 품질 기준
- 모호한 표현 금지: "적절히", "필요에 따라" 대신 구체적 기준 제시
- 전문 용어는 첫 등장 시 괄호 안에 설명 추가
- 순서가 있는 작업은 번호 매기기 사용
- 한 문단은 3-4문장, 한 섹션은 400-800자

### 3. 퀴즈 설계 원칙 (정확히 20문제)
문제 유형 배분:
- 기억형 (40%): 용어, 절차, 규칙을 정확히 기억하는지 확인
- 이해형 (35%): 왜 그렇게 하는지 이유를 이해했는지 확인
- 적용형 (25%): 실제 상황에서 어떻게 적용할지 판단

퀴즈 품질 기준:
- 질문은 명확하고 구체적으로 (무엇을, 언제, 어떻게)
- 정답은 본문 내용에 근거해야 함
- 오답 선지는 그럴듯하지만 명확히 틀린 내용 (흔한 오해 반영)
- 모든 선지 길이는 비슷하게 유지

## 입력 텍스트
${rawText}

## 출력 형식
반드시 아래 JSON 형식으로만 응답하세요. JSON 외 다른 텍스트 없이 출력하세요:

{
  "title": "명확하고 구체적인 문서 제목",
  "estimatedMinutes": 25,
  "sections": [
    {
      "title": "1. 섹션 제목",
      "content": "**학습 목표**: ...\\n\\n**핵심 내용**:\\n...\\n\\n**실무 예시**:\\n...\\n\\n**주의사항**:\\n..."
    }
  ],
  "quiz": [
    {
      "id": 1,
      "question": "구체적인 질문 내용?",
      "options": ["선지A (20자 내외)", "선지B (20자 내외)", "선지C (20자 내외)", "선지D (20자 내외)"],
      "answer": 0
    }
  ]
}

## 체크리스트
- [ ] 섹션 3-5개, 각 섹션 400-800자
- [ ] 퀴즈 정확히 20개
- [ ] answer는 정답 인덱스 (0, 1, 2, 3 중 하나)
- [ ] estimatedMinutes는 40 이하
- [ ] JSON 문법 오류 없음`;

      try {
        // Gemini API 호출
        setProgress && setProgress("Gemini AI 연결 중...");

        const geminiPrompt = prompt.replace('/no_think\n', ''); // Gemini는 /no_think 불필요

        const response = await fetch(
          `${GEMINI_API_URL}/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [{
                parts: [{ text: geminiPrompt }]
              }],
              generationConfig: {
                temperature: 0.3,
                maxOutputTokens: 8192
              }
            })
          }
        );

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(`Gemini API 오류: ${response.status} - ${errorData.error?.message || ''}`);
        }

        setProgress && setProgress("Gemini AI 응답 처리 중...");
        const data = await response.json();

        // Gemini 응답 구조에서 텍스트 추출
        const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        console.log("Gemini raw response:", responseText.substring(0, 500));

        // AI 응답 파싱 (헬퍼 함수 사용)
        let result = parseAIResponseToJSON(responseText);

        // 결과 검증 및 퀴즈 보충 (헬퍼 함수 사용)
        result = validateAndFillOJTResult(result, result.title);

        return result;

      } catch (error) {
        console.error("AI Generation Error:", error);

        // Graceful Degradation: AI 실패 시 원문 기반 fallback
        setProgress && setProgress("AI 분석 실패 - 원문으로 등록 중...");

        // HTML 태그 검사
        const isHtml = /<[a-z][\s\S]*>/i.test(rawText);
        let formattedContent = rawText;

        if (!isHtml) {
          // 플레인 텍스트를 HTML 문단으로 변환
          formattedContent = rawText
            .split(/\n\n+/)
            .filter(p => p.trim())
            .map(p => `<p>${p.trim().replace(/\n/g, '<br>')}</p>`)
            .join('\n');
        }

        // DOMPurify로 XSS 방어
        const sanitizedContent = DOMPurify.sanitize(formattedContent, {
          ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'a', 'pre', 'code'],
          ALLOWED_ATTR: ['href', 'target']
        });

        return {
          title: "학습 자료",
          estimatedMinutes: 15,
          sections: [{
            title: '원문 내용',
            content: sanitizedContent
          }],
          quiz: [],
          ai_processed: false,
          ai_error: error.message
        };
      }
    }

    // =========================================
    // AI 퀴즈 생성 (URL Context Tool 사용)
    // URL 또는 PDF에서 직접 퀴즈만 생성
    // =========================================
    async function generateQuizWithUrlContext(sourceUrl, sourceType, setProgress) {
      const contentTypeLabel = sourceType === 'pdf' ? 'PDF 문서' : '웹페이지';

      const prompt = `당신은 10년 경력의 기업 교육 설계 전문가입니다.

## 작업 요청
다음 ${contentTypeLabel}를 분석하고 신입사원 학습용 퀴즈를 생성하세요.

URL: ${sourceUrl}

## 퀴즈 설계 원칙 (정확히 20문제)
문제 유형 배분:
- 기억형 (40%): 용어, 절차, 규칙을 정확히 기억하는지 확인
- 이해형 (35%): 왜 그렇게 하는지 이유를 이해했는지 확인
- 적용형 (25%): 실제 상황에서 어떻게 적용할지 판단

퀴즈 품질 기준:
- 질문은 명확하고 구체적으로 (무엇을, 언제, 어떻게)
- 정답은 문서 내용에 근거해야 함
- 오답 선지는 그럴듯하지만 명확히 틀린 내용 (흔한 오해 반영)
- 모든 선지 길이는 비슷하게 유지

## 출력 형식
반드시 아래 JSON 형식으로만 응답하세요. JSON 외 다른 텍스트 없이 출력하세요:

{
  "title": "문서 제목 (자동 추출)",
  "estimatedMinutes": 15,
  "quiz": [
    {
      "id": 1,
      "question": "구체적인 질문 내용?",
      "options": ["선지A (20자 내외)", "선지B (20자 내외)", "선지C (20자 내외)", "선지D (20자 내외)"],
      "answer": 0
    }
  ]
}

## 체크리스트
- [ ] 퀴즈 정확히 20개
- [ ] answer는 정답 인덱스 (0, 1, 2, 3 중 하나)
- [ ] estimatedMinutes는 40 이하
- [ ] JSON 문법 오류 없음`;

      try {
        setProgress && setProgress("Gemini AI가 원문을 분석 중...");

        const response = await fetch(
          `${GEMINI_API_URL}/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [{
                parts: [{ text: prompt }]
              }],
              tools: [{ urlContext: {} }],  // URL Context Tool 활성화
              generationConfig: {
                temperature: 0.3,
                maxOutputTokens: 8192
              }
            })
          }
        );

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(`Gemini API 오류: ${response.status} - ${errorData.error?.message || ''}`);
        }

        setProgress && setProgress("퀴즈 응답 처리 중...");
        const data = await response.json();

        // Gemini 응답 구조에서 텍스트 추출
        const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        console.log("Gemini URL Context response:", responseText.substring(0, 500));

        // AI 응답 파싱 (헬퍼 함수 사용)
        let result = parseAIResponseToJSON(responseText);

        // 결과 검증 및 퀴즈 보충 (헬퍼 함수 사용)
        result = validateAndFillOJTResult(result, result.title);

        return result;

      } catch (error) {
        console.error("URL Context AI Error:", error);

        // Graceful Degradation: AI 실패 시 fallback 반환
        setProgress && setProgress("AI 분석 실패 - 원문으로 등록 중...");

        return {
          title: `${contentTypeLabel} 학습 자료`,
          estimatedMinutes: 15,
          quiz: [],
          ai_processed: false,
          ai_error: error.message
        };
      }
    }

    // =========================================
    // PDF R2 업로드 함수
    // =========================================
    async function uploadPdfToR2(file) {
      // 파일 유효성 검사
      if (!file) {
        throw new Error('파일이 선택되지 않았습니다');
      }

      if (file.type !== 'application/pdf') {
        throw new Error('PDF 파일만 업로드 가능합니다');
      }

      if (file.size > R2_MAX_FILE_SIZE) {
        throw new Error('파일 크기는 10MB를 초과할 수 없습니다');
      }

      try {
        // 1. Worker에 업로드 URL 요청
        const prepareRes = await fetch(R2_WORKER_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filename: file.name,
            contentType: 'application/pdf',
            fileSize: file.size
          })
        });

        if (!prepareRes.ok) {
          const error = await prepareRes.json();
          throw new Error(error.error || 'PDF 업로드 준비 실패');
        }

        const { key, publicUrl } = await prepareRes.json();

        // 2. 실제 파일 업로드
        const uploadRes = await fetch(`${R2_WORKER_URL}/upload`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/pdf',
            'X-Upload-Key': key
          },
          body: file
        });

        if (!uploadRes.ok) {
          const error = await uploadRes.json();
          throw new Error(error.error || 'PDF 업로드 실패');
        }

        const result = await uploadRes.json();
        console.log('PDF uploaded to R2:', result.url);

        return result.url;

      } catch (error) {
        console.error('PDF R2 upload error:', error);
        throw error;
      }
    }

    // =========================================
    // Main App
    // =========================================
    function App() {
      // User State
      const [user, setUser] = useState(null);
      const [isLoadingAuth, setIsLoadingAuth] = useState(true);

      // AI Status (Gemini)
      const [aiStatus, setAiStatus] = useState({ online: false, provider: null, model: null });
      const [showSettings, setShowSettings] = useState(false);

      // App State
      const [viewState, setViewState] = useState('loading');

      // Admin Mode Switch (임시 모드 전환)
      const [sessionMode, setSessionMode] = useState(null); // 'admin' | 'mentor' | null
      const [showModeMenu, setShowModeMenu] = useState(false);
      // 성능 최적화: displayRole을 useMemo로 캐싱
      const displayRole = useMemo(() => sessionMode || user?.role, [sessionMode, user?.role]);

      // Mentor State
      const [inputType, setInputType] = useState('text'); // 'text', 'url', 'pdf'
      const [inputTitle, setInputTitle] = useState('');
      const [rawInput, setRawInput] = useState('');
      const [urlInput, setUrlInput] = useState('');
      const [pdfFile, setPdfFile] = useState(null);
      // Quill Editor
      const quillRef = useRef(null);
      const quillInstanceRef = useRef(null);
      const [inputTeam, setInputTeam] = useState(TEAMS[0]);
      const [inputStep, setInputStep] = useState(1);
      const [isCustomTeam, setIsCustomTeam] = useState(false);
      const [isCustomStep, setIsCustomStep] = useState(false);
      const [isProcessing, setIsProcessing] = useState(false);
      const [processingStatus, setProcessingStatus] = useState('');
      const [generatedDoc, setGeneratedDoc] = useState(null);
      const [generatedDocs, setGeneratedDocs] = useState([]); // 분할된 여러 문서
      const [myDocs, setMyDocs] = useState([]);
      const [editingDoc, setEditingDoc] = useState(null); // 편집 중인 문서
      const [autoSplit, setAutoSplit] = useState(true); // 자동 스텝 분할 옵션
      // 성능 최적화: 예상 학습 시간/스텝 수를 useMemo로 계산 (불필요한 state 업데이트 방지)
      const estimatedTime = useMemo(() => rawInput ? estimateReadingTime(rawInput) : 0, [rawInput]);
      const requiredSteps = useMemo(() => rawInput ? calculateRequiredSteps(rawInput) : 1, [rawInput]);
      const [editorTab, setEditorTab] = useState('edit'); // 'edit' | 'preview' - 탭 기반 레이아웃
      const [showQuizPreview, setShowQuizPreview] = useState(false); // 퀴즈 미리보기 모달
      const [quizEditMode, setQuizEditMode] = useState(false); // 퀴즈 편집 모드
      const [editingQuizIndex, setEditingQuizIndex] = useState(null); // 편집 중인 퀴즈 인덱스

      // Mentee State
      const [publicDocs, setPublicDocs] = useState([]);
      const [selectedTeam, setSelectedTeam] = useState(null);
      const [selectedDoc, setSelectedDoc] = useState(null);

      // Quiz State
      const [quizMode, setQuizMode] = useState(false);
      const [activeQuizSet, setActiveQuizSet] = useState([]);
      const [currentQuizIndex, setCurrentQuizIndex] = useState(0);
      const [selectedAnswers, setSelectedAnswers] = useState({});
      const [quizSubmitted, setQuizSubmitted] = useState(false);
      const [score, setScore] = useState(0);
      const [passed, setPassed] = useState(false);

      // =========================================
      // Effects
      // =========================================

      // AI 상태 체크 (Gemini) - 앱 시작 시 1회만
      useEffect(() => {
        const checkStatus = async () => {
          const status = await checkGeminiStatus();
          setAiStatus(status);
        };
        checkStatus();
      }, []);

      // Admin 모드 전환 상태 복원 (sessionStorage)
      useEffect(() => {
        const stored = SecureSession.get('ojt_sessionMode');
        if (stored && ['admin', 'mentor'].includes(stored)) {
          setSessionMode(stored);
        }
      }, []);

      // 모드 메뉴 외부 클릭 시 닫기
      useEffect(() => {
        const handleClickOutside = (e) => {
          if (showModeMenu && !e.target.closest('.mode-menu-container')) {
            setShowModeMenu(false);
          }
        };
        document.addEventListener('click', handleClickOutside);
        return () => document.removeEventListener('click', handleClickOutside);
      }, [showModeMenu]);

      // 입력 내용 변경 시 예상 학습 시간/스텝 수는 useMemo로 계산됨 (위의 estimatedTime, requiredSteps)

      // 이미지 업로드 상태
      const [isUploadingImage, setIsUploadingImage] = useState(false);

      // Quill 커스텀 이미지 핸들러
      const handleQuillImageUpload = async () => {
        const input = document.createElement('input');
        input.setAttribute('type', 'file');
        input.setAttribute('accept', 'image/jpeg,image/png,image/gif,image/webp');
        input.click();

        input.onchange = async () => {
          const file = input.files[0];
          if (!file) return;

          setIsUploadingImage(true);
          try {
            const imageUrl = await uploadImageToR2(file);

            // Quill에 이미지 삽입
            const quill = quillInstanceRef.current;
            if (quill) {
              const range = quill.getSelection(true);
              quill.insertEmbed(range.index, 'image', imageUrl);
              quill.setSelection(range.index + 1);
            }
          } catch (error) {
            Toast.error(`이미지 업로드 실패: ${error.message}`);
          } finally {
            setIsUploadingImage(false);
          }
        };
      };

      // Quill 드래그&드롭/붙여넣기 이미지 처리
      const handleQuillImageDrop = async (file) => {
        if (!R2_ALLOWED_TYPES.includes(file.type)) {
          Toast.error('허용되지 않는 파일 형식입니다. (JPG, PNG, GIF, WebP만 지원)');
          return;
        }

        setIsUploadingImage(true);
        try {
          const imageUrl = await uploadImageToR2(file);

          const quill = quillInstanceRef.current;
          if (quill) {
            const range = quill.getSelection(true);
            quill.insertEmbed(range.index, 'image', imageUrl);
            quill.setSelection(range.index + 1);
          }
        } catch (error) {
          Toast.error(`이미지 업로드 실패: ${error.message}`);
        } finally {
          setIsUploadingImage(false);
        }
      };

      // Quill 에디터 초기화
      useEffect(() => {
        if (inputType === 'text' && quillRef.current && !quillInstanceRef.current) {
          // Quill 인스턴스 생성
          quillInstanceRef.current = new Quill(quillRef.current, {
            theme: 'snow',
            placeholder: '교육 내용을 자유롭게 입력하세요...\n\n• 서식 도구를 사용하여 제목, 목록, 강조 등을 추가할 수 있습니다\n• Ctrl+B: 굵게, Ctrl+I: 기울임, Ctrl+U: 밑줄\n• 이미지: 툴바 버튼 또는 드래그&드롭/붙여넣기',
            modules: {
              toolbar: {
                container: [
                  [{ 'header': [1, 2, 3, false] }],
                  ['bold', 'italic', 'underline', 'strike'],
                  [{ 'color': [] }, { 'background': [] }],
                  [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                  [{ 'indent': '-1'}, { 'indent': '+1' }],
                  ['blockquote', 'code-block'],
                  ['link', 'image'],
                  ['clean']
                ],
                handlers: {
                  image: handleQuillImageUpload
                }
              }
            }
          });

          // 텍스트 변경 시 rawInput 업데이트
          quillInstanceRef.current.on('text-change', () => {
            const text = quillInstanceRef.current.getText().trim();
            setRawInput(text);
          });

          // 드래그&드롭 이미지 처리
          const editorContainer = quillRef.current.querySelector('.ql-editor');
          if (editorContainer) {
            editorContainer.addEventListener('drop', async (e) => {
              e.preventDefault();
              editorContainer.classList.remove('drag-over');
              const files = e.dataTransfer?.files;
              if (files && files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                  await handleQuillImageDrop(file);
                }
              }
            });

            editorContainer.addEventListener('dragover', (e) => {
              e.preventDefault();
              editorContainer.classList.add('drag-over');
            });

            editorContainer.addEventListener('dragleave', (e) => {
              e.preventDefault();
              editorContainer.classList.remove('drag-over');
            });

            // 붙여넣기 이미지 처리
            editorContainer.addEventListener('paste', async (e) => {
              const items = e.clipboardData?.items;
              if (items) {
                for (let i = 0; i < items.length; i++) {
                  if (items[i].type.startsWith('image/')) {
                    e.preventDefault();
                    const file = items[i].getAsFile();
                    if (file) {
                      await handleQuillImageDrop(file);
                    }
                    break;
                  }
                }
              }
            });
          }

          // 편집 모드인 경우 기존 내용 로드 (Quill 마운트 후)
          if (editingDoc && editingDoc.sections && editingDoc.sections.length > 0) {
            const contentText = editingDoc.sections.map(section => {
              let text = `## ${section.title}\n\n`;
              if (section.content) {
                text += section.content + '\n\n';
              }
              return text;
            }).join('');
            quillInstanceRef.current.setText(contentText);
            console.log('Quill: loaded editingDoc content on mount');
          }
        }

        // 메모리 누수 방지: Quill 인스턴스 및 이벤트 리스너 정리
        return () => {
          if (quillInstanceRef.current) {
            // Quill 이벤트 리스너 해제
            quillInstanceRef.current.off('text-change');

            // 에디터 DOM 이벤트 리스너는 요소 제거 시 자동 정리됨
            // 단, 인스턴스 참조는 명시적으로 해제
            if (inputType !== 'text') {
              quillInstanceRef.current = null;
            }
          }
        };
      }, [inputType, viewState, editingDoc]);

      // 역할 기반 뷰 상태 결정 헬퍼
      const getViewStateByRole = (role, tempMode = null) => {
        const roleViewMap = {
          admin: 'admin_dashboard',
          mentor: 'mentor_dashboard',
          mentee: 'mentee_list'
        };

        // Admin이 Mentor 모드로 전환된 경우
        if (role === 'admin' && tempMode === 'mentor') {
          return 'mentor_dashboard';
        }

        return roleViewMap[role] || 'role_select';
      };

      // 세션에서 기본 사용자 정보 추출 헬퍼
      const extractUserFromSession = (session) => ({
        id: session.user.id,
        name: session.user.user_metadata?.full_name || session.user.email?.split('@')[0] || 'User',
        email: session.user.email,
        role: null
      });

      // 사용자 프로필 로드 및 뷰 상태 설정 (공통 함수)
      const loadUserProfile = async (session) => {
        console.log("loadUserProfile called, session:", session?.user?.email);

        // 세션 없음: 로그인 화면으로
        if (!session?.user) {
          console.log("No session user, redirecting to login");
          setUser(null);
          setViewState('login');
          setIsLoadingAuth(false);
          return;
        }

        try {
          console.log("Fetching profile for user:", session.user.id);
          const profile = await dbGet("users", session.user.id);
          console.log("Profile fetched:", profile);

          // 프로필과 역할이 있는 경우
          if (profile?.role) {
            setUser(profile);
            const tempMode = SecureSession.get('ojt_sessionMode');
            const viewState = getViewStateByRole(profile.role, tempMode);

            // Admin의 Mentor 모드 전환 시 sessionMode도 설정
            if (profile.role === 'admin' && tempMode === 'mentor') {
              setSessionMode('mentor');
            }

            console.log("Setting viewState to:", viewState);
            setViewState(viewState);
            setIsLoadingAuth(false);
            return;
          }

          // 프로필 없거나 역할 없음: 역할 선택 화면으로
          console.log("No profile or role, showing role select");
          setUser(extractUserFromSession(session));
          setViewState('role_select');
          setIsLoadingAuth(false);

        } catch (e) {
          console.error("Load user profile error:", e);
          // 에러 시에도 역할 선택 화면으로 (로그인 상태 유지)
          setUser(extractUserFromSession(session));
          setViewState('role_select');
          setIsLoadingAuth(false);
        }
      };

      // 초기 로드: Supabase Auth 세션 확인 (onAuthStateChange 기반)
      useEffect(() => {
        let isMounted = true;
        let profileLoaded = false; // 중복 호출 방지 플래그

        console.log("Auth: subscribing to onAuthStateChange...");

        // 10초 후에도 이벤트 없으면 로그인 화면 표시 (fallback)
        const fallbackTimer = setTimeout(() => {
          if (isMounted && !profileLoaded) {
            console.log("Auth: fallback timeout, showing login");
            setViewState('login');
            setIsLoadingAuth(false);
          }
        }, 10000);

        // 인증 상태 변경 구독 (Supabase 권장 패턴)
        const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {
          console.log('Auth event:', event, session?.user?.email);

          if (!isMounted) return;

          // 토큰 갱신은 UI 변경 불필요
          if (event === 'TOKEN_REFRESHED') {
            console.log('Auth: token refreshed, no UI change');
            return;
          }

          // INITIAL_SESSION: 앱 시작 시 기존 세션 확인
          if (event === 'INITIAL_SESSION') {
            clearTimeout(fallbackTimer);
            if (session?.user && !profileLoaded) {
              console.log('Auth: INITIAL_SESSION with user');
              profileLoaded = true;
              await loadUserProfile(session);
            } else if (session?.user && profileLoaded) {
              console.log('Auth: INITIAL_SESSION skipped (already loaded)');
            } else {
              console.log('Auth: INITIAL_SESSION no user, showing login');
              setViewState('login');
              setIsLoadingAuth(false);
            }
            return;
          }

          if (event === 'SIGNED_OUT') {
            profileLoaded = false;
            setUser(null);
            setViewState('login');
            setIsLoadingAuth(false);
            return;
          }

          // SIGNED_IN: OAuth 로그인 완료
          if (event === 'SIGNED_IN') {
            clearTimeout(fallbackTimer);
            if (session?.user && !profileLoaded) {
              console.log('Auth: SIGNED_IN, loading profile');
              profileLoaded = true;
              await loadUserProfile(session);
            } else if (profileLoaded) {
              console.log('Auth: SIGNED_IN skipped (already loaded)');
            }
          }
        });

        return () => {
          isMounted = false;
          clearTimeout(fallbackTimer);
          subscription.unsubscribe();
        };
      }, []);

      // 멘토/Admin(Mentor모드): 내 문서 로드
      useEffect(() => {
        // 실제 mentor이거나, admin이 mentor 모드로 전환한 경우
        const shouldLoadMyDocs = user && (
          user.role === 'mentor' ||
          (user.role === 'admin' && sessionMode === 'mentor')
        );
        if (!shouldLoadMyDocs) return;

        const loadMyDocs = async () => {
          const docs = await dbGetAll("ojt_docs", { authorId: user.id });
          // Supabase 필드명을 앱 형식으로 매핑
          const mapped = docs.map(doc => ({
            ...doc,
            authorId: doc.author_id,
            author: doc.author_name,
            estimatedMinutes: doc.estimated_minutes,
            createdAt: new Date(doc.created_at).getTime()
          }));
          setMyDocs(mapped);
          console.log('myDocs loaded:', mapped.length, 'documents');
        };
        loadMyDocs();
      }, [user, sessionMode, generatedDoc]); // sessionMode 변경 시에도 리로드

      // 멘티: 모든 문서 로드
      useEffect(() => {
        if (!user || user.role !== 'mentee') return;
        const loadPublicDocs = async () => {
          const docs = await dbGetAll("ojt_docs");
          // Supabase 필드명을 앱 형식으로 매핑
          const mapped = docs.map(doc => ({
            ...doc,
            authorId: doc.author_id,
            author: doc.author_name,
            estimatedMinutes: doc.estimated_minutes,
            createdAt: new Date(doc.created_at).getTime()
          }));
          setPublicDocs(mapped);
        };
        loadPublicDocs();
      }, [user]);

      // =========================================
      // Auth Handlers
      // =========================================
      const handleGoogleLogin = async () => {
        try {
          // OAuth Redirect URI 검증: 허용된 도메인만 리다이렉트
          const currentOrigin = window.location.origin;
          const redirectOrigin = CONFIG.ALLOWED_ORIGINS.includes(currentOrigin)
            ? currentOrigin
            : CONFIG.ALLOWED_ORIGINS[0]; // 기본값: 프로덕션 URL

          const { error } = await supabase.auth.signInWithOAuth({
            provider: 'google',
            options: {
              redirectTo: redirectOrigin
            }
          });
          if (error) throw error;
        } catch (e) {
          console.error("Google login error:", e);
          Toast.error("Google 로그인 중 오류가 발생했습니다: " + e.message);
        }
      };

      const handleRoleSelect = async (selectedRole) => {
        if (!user) return;
        try {
          const userData = {
            id: user.id,
            name: user.name,
            role: selectedRole,
            department: null
          };
          await dbPut("users", userData);
          setUser(userData);

          if (selectedRole === 'mentor') setViewState('mentor_dashboard');
          else setViewState('mentee_list');
        } catch (e) {
          console.error("Role save error:", e);
          Toast.error("역할 저장 중 오류가 발생했습니다.");
        }
      };

      const handleLogout = async () => {
        try {
          // 캐시 먼저 클리어 (다른 사용자 데이터 노출 방지)
          await clearAllCache();
          // 모드 전환 상태 초기화
          SecureSession.remove('ojt_sessionMode');
          setSessionMode(null);
          setShowModeMenu(false);
          await supabase.auth.signOut();
          setUser(null);
          setViewState('login');
        } catch (e) {
          console.error("Logout error:", e);
        }
      };

      // Admin 모드 전환 핸들러
      const handleModeSwitch = (newMode) => {
        if (newMode === null) {
          // Admin 모드로 복귀
          SecureSession.remove('ojt_sessionMode');
          setSessionMode(null);
          setViewState('admin_dashboard');
        } else {
          // Mentor 모드로 전환
          SecureSession.set('ojt_sessionMode', newMode);
          setSessionMode(newMode);
          setViewState('mentor_dashboard');
        }
        setShowModeMenu(false);
      };

      // =========================================
      // Mentor Handlers
      // =========================================
      const handleGenerate = async () => {
        // 입력 타입에 따른 검증
        if (inputType === 'text' && !rawInput.trim()) {
          Toast.warning("텍스트를 입력해주세요.");
          return;
        }
        if (inputType === 'url' && !urlInput.trim()) {
          Toast.warning("URL을 입력해주세요.");
          return;
        }
        if (inputType === 'pdf' && !pdfFile) {
          Toast.warning("PDF 파일을 선택해주세요.");
          return;
        }
        if (!aiStatus.online) {
          Toast.error("Gemini AI 서비스에 연결할 수 없습니다. API 키를 확인해주세요.");
          return;
        }

        setIsProcessing(true);
        setGeneratedDoc(null);
        setGeneratedDocs([]);

        try {
          // =========================================
          // URL/PDF: URL Context Tool로 퀴즈만 생성 (원문 보존)
          // =========================================
          if (inputType === 'url') {
            setProcessingStatus("URL 유효성 검사 중...");

            // URL 유효성 검증
            try {
              new URL(urlInput);
            } catch {
              throw new Error("올바른 URL 형식이 아닙니다.");
            }

            setProcessingStatus("Gemini AI가 URL을 분석 중...");
            const aiResult = await generateQuizWithUrlContext(urlInput, 'url', setProcessingStatus);
            const finalTitle = inputTitle.trim() || aiResult.title || "URL 학습 자료";

            const finalDoc = {
              ...aiResult,
              title: finalTitle,
              team: inputTeam,
              step: parseInt(inputStep),
              source_type: 'url',
              source_url: urlInput,
              sections: [] // URL 원문은 sections 없음 (원문 보기로 대체)
            };

            setInputTitle(finalTitle);
            setGeneratedDoc(finalDoc);
            setGeneratedDocs([finalDoc]);
            setProcessingStatus("");
            setEditorTab('preview');

            // AI 처리 결과에 따른 메시지
            if (aiResult.ai_processed === false) {
              Toast.warning(`AI 분석 실패: ${aiResult.ai_error || '알 수 없는 오류'}. 퀴즈 없이 원문으로 등록됩니다.`);
            } else {
              Toast.success("URL 분석 완료! 퀴즈가 생성되었습니다.");
            }
            return;
          }

          if (inputType === 'pdf') {
            setProcessingStatus("PDF 파일 업로드 중...");

            // PDF를 R2에 업로드
            const pdfUrl = await uploadPdfToR2(pdfFile);

            setProcessingStatus("Gemini AI가 PDF를 분석 중...");
            const aiResult = await generateQuizWithUrlContext(pdfUrl, 'pdf', setProcessingStatus);
            const finalTitle = inputTitle.trim() || aiResult.title || pdfFile.name.replace('.pdf', '');

            const finalDoc = {
              ...aiResult,
              title: finalTitle,
              team: inputTeam,
              step: parseInt(inputStep),
              source_type: 'pdf',
              source_file: pdfUrl,
              sections: [] // PDF 원문은 sections 없음 (PDF 뷰어로 대체)
            };

            setInputTitle(finalTitle);
            setGeneratedDoc(finalDoc);
            setGeneratedDocs([finalDoc]);
            setProcessingStatus("");
            setEditorTab('preview');

            // AI 처리 결과에 따른 메시지
            if (aiResult.ai_processed === false) {
              Toast.warning(`AI 분석 실패: ${aiResult.ai_error || '알 수 없는 오류'}. 퀴즈 없이 원문으로 등록됩니다.`);
            } else {
              Toast.success("PDF 분석 완료! 퀴즈가 생성되었습니다.");
            }
            return;
          }

          // =========================================
          // 텍스트: 기존 방식 (섹션 + 퀴즈 생성)
          // =========================================
          setProcessingStatus("콘텐츠 추출 중...");
          let contentText = '';

          // Quill에서 서식 있는 HTML과 플레인 텍스트 모두 가져오기
          if (quillInstanceRef.current) {
            const rawHtml = quillInstanceRef.current.root.innerHTML;
            const plainText = quillInstanceRef.current.getText().trim();
            // XSS 방어: DOMPurify로 HTML sanitize
            const html = DOMPurify.sanitize(rawHtml, {
              ALLOWED_TAGS: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li', 'blockquote', 'pre', 'code', 'a', 'img', 'span', 's'],
              ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'style'],
              ALLOW_DATA_ATTR: false
            });
            // HTML이 의미 있는 서식을 포함하면 HTML 사용, 아니면 플레인 텍스트 사용
            const hasFormatting = /<(h[1-6]|strong|em|u|ol|ul|li|blockquote|pre)/.test(html);
            contentText = hasFormatting ? html : plainText;
          } else {
            contentText = rawInput;
          }

          if (!contentText.trim()) {
            throw new Error("텍스트를 입력해주세요.");
          }

          // 자동 분할 여부 확인
          const numSteps = autoSplit ? calculateRequiredSteps(contentText) : 1;

          if (numSteps > 1) {
            // 여러 스텝으로 분할 생성 (병렬 처리로 속도 향상)
            const segments = splitContentForSteps(contentText, numSteps);
            const baseStep = parseInt(inputStep);
            const baseTitle = inputTitle.trim();

            setProcessingStatus(`AI 병렬 생성 중... (${segments.length}개 스텝)`);

            // 모든 스텝을 병렬로 생성 (Promise.all)
            const generatePromises = segments.map((segment, i) => {
              const stepNum = baseStep + i;
              return generateOJTContent(
                segment,
                inputTeam,
                stepNum,
                null, // 병렬 처리 시 개별 진행 상태 표시 어려움
                segments.length
              ).then(aiResult => {
                const stepTitle = baseTitle
                  ? `${baseTitle} - Step ${stepNum}`
                  : `${aiResult.title} - Step ${stepNum}`;

                return {
                  ...aiResult,
                  title: stepTitle,
                  team: inputTeam,
                  step: stepNum,
                  totalSteps: segments.length,
                  stepIndex: i + 1,
                  source_type: 'manual'
                };
              });
            });

            // 모든 스텝 생성 완료 대기
            const results = await Promise.all(generatePromises);

            // 스텝 순서대로 정렬
            results.sort((a, b) => a.step - b.step);

            setGeneratedDocs(results);
            setGeneratedDoc(results[0]); // 첫 번째 문서를 미리보기에 표시
            setProcessingStatus("");
            setEditorTab('preview'); // 미리보기 탭으로 자동 전환

            // AI 처리 실패 문서가 있는지 확인
            const failedDocs = results.filter(r => r.ai_processed === false);
            if (failedDocs.length > 0) {
              Toast.warning(`AI 분석 실패 ${failedDocs.length}개. 퀴즈 없이 원문으로 등록됩니다.`);
            } else {
              Toast.success(`${results.length}개의 교육 자료가 생성되었습니다!`);
            }
          } else {
            // 단일 스텝 생성
            setProcessingStatus("AI 생성 시작...");
            const aiResult = await generateOJTContent(contentText, inputTeam, inputStep, setProcessingStatus);
            const finalTitle = inputTitle.trim() || aiResult.title;
            setInputTitle(finalTitle);
            const finalDoc = {
              ...aiResult,
              title: finalTitle,
              team: inputTeam,
              step: parseInt(inputStep),
              source_type: 'manual'
            };
            setGeneratedDoc(finalDoc);
            setGeneratedDocs([finalDoc]);
            setProcessingStatus("");
            setEditorTab('preview'); // 미리보기 탭으로 자동 전환

            // AI 처리 결과에 따른 메시지
            if (aiResult.ai_processed === false) {
              Toast.warning(`AI 분석 실패: ${aiResult.ai_error || '알 수 없는 오류'}. 퀴즈 없이 원문으로 등록됩니다.`);
            } else {
              Toast.success("교육 자료가 생성되었습니다!");
            }
          }
        } catch (error) {
          Toast.error(`오류: ${error.message}`);
          setProcessingStatus("");
        }

        setIsProcessing(false);
      };

      const handleSaveToDB = async () => {
        if (!user || (!generatedDoc && generatedDocs.length === 0)) return;

        try {
          const docsToSave = generatedDocs.length > 0 ? generatedDocs : [generatedDoc];
          let savedCount = 0;

          for (const doc of docsToSave) {
            const docToSave = {
              ...doc,
              title: doc.title || inputTitle || "제목 없음",
              team: inputTeam,
              step: doc.step || parseInt(inputStep),
              author: user.name,
              authorId: user.id
            };

            // 편집 모드: 기존 문서 업데이트
            if (editingDoc && savedCount === 0) {
              docToSave.id = editingDoc.id;
              docToSave.createdAt = editingDoc.createdAt;
              docToSave.updatedAt = Date.now();
              await dbPut("ojt_docs", docToSave);
            } else {
              // 신규 모드: 새 문서 추가
              docToSave.createdAt = Date.now() + savedCount;
              await dbAdd("ojt_docs", docToSave);
            }
            savedCount++;
          }

          const message = editingDoc
            ? `문서가 수정되었습니다.`
            : `${savedCount}개 문서가 저장되었습니다.`;
          Toast.success(message);

          // 상태 초기화
          setEditingDoc(null);
          setGeneratedDoc(null);
          setGeneratedDocs([]);
          setRawInput("");
          setUrlInput("");
          setPdfFile(null);
          setInputTitle("");
          // 저장 후 자동 분할 복원
          setAutoSplit(true);
          // Quill 에디터 초기화
          if (quillInstanceRef.current) {
            quillInstanceRef.current.setText('');
          }
          // 목록 새로고침
          const allDocs = await dbGetAll("ojt_docs");
          const filtered = allDocs.filter(doc => doc.authorId === user.id);
          filtered.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
          setMyDocs(filtered);
        } catch (e) {
          console.error("Save error:", e);
          Toast.error("저장 중 오류가 발생했습니다.");
        }
      };

      const handleDeleteDoc = async (docId) => {
        const doc = myDocs.find(d => d.id === docId);
        if (!doc) return;

        // CSRF 방어: 2단계 확인 (공통 헬퍼 사용)
        if (!confirmDeleteWithCSRF(doc.title)) return;

        try {
          await dbDelete("ojt_docs", docId);
          setMyDocs(prev => prev.filter(d => d.id !== docId));
        } catch (e) {
          console.error("Delete error:", e);
        }
      };

      // 퀴즈 수정 핸들러들 (generatedDoc 또는 editingDoc 지원)
      const handleQuizQuestionChange = (quizIndex, newQuestion) => {
        // editingDoc 우선, 없으면 generatedDoc
        if (editingDoc?.quiz) {
          const updatedQuiz = [...editingDoc.quiz];
          updatedQuiz[quizIndex] = { ...updatedQuiz[quizIndex], question: newQuestion };
          setEditingDoc({ ...editingDoc, quiz: updatedQuiz });
        } else if (generatedDoc?.quiz) {
          const updatedQuiz = [...generatedDoc.quiz];
          updatedQuiz[quizIndex] = { ...updatedQuiz[quizIndex], question: newQuestion };
          setGeneratedDoc({ ...generatedDoc, quiz: updatedQuiz });
          if (generatedDocs.length > 0) {
            const docIndex = generatedDocs.findIndex(d => d === generatedDoc);
            if (docIndex !== -1) {
              const updatedDocs = [...generatedDocs];
              updatedDocs[docIndex] = { ...generatedDoc, quiz: updatedQuiz };
              setGeneratedDocs(updatedDocs);
            }
          }
        }
      };

      const handleQuizOptionChange = (quizIndex, optionIndex, newOption) => {
        const targetDoc = editingDoc?.quiz ? editingDoc : generatedDoc;
        if (!targetDoc?.quiz) return;
        const updatedQuiz = [...targetDoc.quiz];
        const updatedOptions = [...updatedQuiz[quizIndex].options];
        const wasAnswer = updatedQuiz[quizIndex].answer === updatedOptions[optionIndex];
        updatedOptions[optionIndex] = newOption;
        updatedQuiz[quizIndex] = { 
          ...updatedQuiz[quizIndex], 
          options: updatedOptions,
          answer: wasAnswer ? newOption : updatedQuiz[quizIndex].answer
        };
        if (editingDoc?.quiz) {
          setEditingDoc({ ...editingDoc, quiz: updatedQuiz });
        } else {
          setGeneratedDoc({ ...generatedDoc, quiz: updatedQuiz });
          if (generatedDocs.length > 0) {
            const docIndex = generatedDocs.findIndex(d => d === generatedDoc);
            if (docIndex !== -1) {
              const updatedDocs = [...generatedDocs];
              updatedDocs[docIndex] = { ...generatedDoc, quiz: updatedQuiz };
              setGeneratedDocs(updatedDocs);
            }
          }
        }
      };

      const handleQuizCorrectChange = (quizIndex, optionIndex) => {
        const targetDoc = editingDoc?.quiz ? editingDoc : generatedDoc;
        if (!targetDoc?.quiz) return;
        const updatedQuiz = [...targetDoc.quiz];
        updatedQuiz[quizIndex] = { 
          ...updatedQuiz[quizIndex], 
          correct: optionIndex,
          answer: updatedQuiz[quizIndex].options[optionIndex]
        };
        if (editingDoc?.quiz) {
          setEditingDoc({ ...editingDoc, quiz: updatedQuiz });
        } else {
          setGeneratedDoc({ ...generatedDoc, quiz: updatedQuiz });
          if (generatedDocs.length > 0) {
            const docIndex = generatedDocs.findIndex(d => d === generatedDoc);
            if (docIndex !== -1) {
              const updatedDocs = [...generatedDocs];
              updatedDocs[docIndex] = { ...generatedDoc, quiz: updatedQuiz };
              setGeneratedDocs(updatedDocs);
            }
          }
        }
      };

      const handleQuizDelete = (quizIndex) => {
        const targetDoc = editingDoc?.quiz ? editingDoc : generatedDoc;
        if (!targetDoc?.quiz || targetDoc.quiz.length <= 4) {
          Toast.warning('최소 4개 이상의 퀴즈가 필요합니다.');
          return;
        }
        const updatedQuiz = targetDoc.quiz.filter((_, idx) => idx !== quizIndex);
        if (editingDoc?.quiz) {
          setEditingDoc({ ...editingDoc, quiz: updatedQuiz });
        } else {
          setGeneratedDoc({ ...generatedDoc, quiz: updatedQuiz });
          if (generatedDocs.length > 0) {
            const docIndex = generatedDocs.findIndex(d => d === generatedDoc);
            if (docIndex !== -1) {
              const updatedDocs = [...generatedDocs];
              updatedDocs[docIndex] = { ...generatedDoc, quiz: updatedQuiz };
              setGeneratedDocs(updatedDocs);
            }
          }
        }
        Toast.success('퀴즈가 삭제되었습니다.');
      };

      // 문서 편집 핸들러 - 기존 문서를 편집창에 로드
      const handleEditDoc = (doc) => {
        setEditingDoc(doc);
        setInputTitle(doc.title || '');
        setInputTeam(doc.team || TEAMS[0]);
        setInputStep(doc.step || 1);

        // 편집 모드에서는 자동 분할 비활성화 (충돌 방지)
        setAutoSplit(false);

        // 섹션 내용을 텍스트로 변환하여 에디터에 로드
        if (doc.sections && doc.sections.length > 0) {
          const contentText = doc.sections.map(section => {
            let text = `## ${section.title}\n\n`;
            if (section.content) {
              text += section.content + '\n\n';
            }
            return text;
          }).join('');

          setRawInput(contentText);

          // Quill 에디터에 내용 설정
          if (quillInstanceRef.current) {
            quillInstanceRef.current.setText(contentText);
          }
        }

        // 기존 생성 결과 초기화
        setGeneratedDoc(null);
        setGeneratedDocs([]);

        // 스크롤 맨 위로
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };

      // 편집 취소 핸들러
      const handleCancelEdit = () => {
        setEditingDoc(null);
        setInputTitle('');
        setRawInput('');
        setGeneratedDoc(null);
        setGeneratedDocs([]);
        // 편집 모드 해제 시 자동 분할 복원
        setAutoSplit(true);
        if (quillInstanceRef.current) {
          quillInstanceRef.current.setText('');
        }
      };

      // =========================================
      // Mentee Handlers
      // =========================================
      const handleSelectDoc = (doc) => {
        setSelectedDoc(doc);
        setQuizMode(false);
        setViewState('mentee_study');
      };

      const startQuizSession = () => {
        if (!selectedDoc || !selectedDoc.quiz) return;

        const fullPool = [...selectedDoc.quiz];

        // 퀴즈 4개 미만 검증
        if (fullPool.length < CONFIG.QUIZ_QUESTIONS_PER_TEST) {
          Toast.warning(`퀴즈가 ${fullPool.length}개뿐입니다. 최소 ${CONFIG.QUIZ_QUESTIONS_PER_TEST}개 필요 (문서 관리자 문의)`);
          return;
        }

        // Fisher-Yates 셔플
        for (let i = fullPool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [fullPool[i], fullPool[j]] = [fullPool[j], fullPool[i]];
        }
        setActiveQuizSet(fullPool.slice(0, CONFIG.QUIZ_QUESTIONS_PER_TEST));
        setQuizMode(true);
        setSelectedAnswers({});
        setQuizSubmitted(false);
        setCurrentQuizIndex(0);
        setScore(0);
        setPassed(false);
      };

      const handleAnswerSelect = (qIndex, optionIndex) => {
        if (quizSubmitted) return;
        setSelectedAnswers(prev => ({ ...prev, [qIndex]: optionIndex }));
      };

      const submitQuiz = () => {
        if (!activeQuizSet.length) return;
        let correctCount = 0;
        activeQuizSet.forEach((q, idx) => {
          // 버그 수정: hasOwnProperty로 인덱스 0도 정확히 검증
          if (Object.prototype.hasOwnProperty.call(selectedAnswers, idx) && selectedAnswers[idx] === q.answer) {
            correctCount++;
          }
        });
        setScore(correctCount);
        setPassed(correctCount >= QUIZ_PASS_THRESHOLD);
        setQuizSubmitted(true);
      };

      // =========================================
      // Views
      // =========================================

      const AIStatusBadge = () => {
        // AI 온라인 상태
        if (aiStatus.online) {
          return (
            <div className="flex items-center gap-2 px-3 py-1 rounded-full text-xs font-bold bg-blue-100 text-blue-700">
              <Icon name="server" className="w-3 h-3" />
              Gemini: {GEMINI_MODEL}
            </div>
          );
        }

        // AI 오프라인 상태
        return (
          <div className="flex items-center gap-2 px-3 py-1 rounded-full text-xs font-bold bg-red-100 text-red-700">
            <Icon name="server" className="w-3 h-3" />
            AI 오프라인
          </div>
        );
      };

      const LoginPage = () => {
        return (
          <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-indigo-50 via-white to-purple-50 p-6">
            <div className="max-w-md w-full bg-white rounded-2xl shadow-2xl p-10 text-center">
              <div className="mb-8">
                <div className="w-20 h-20 bg-indigo-100 rounded-full flex items-center justify-center mx-auto mb-4">
                  <Icon name="brain" className="w-12 h-12 text-indigo-600" />
                </div>
                <h1 className="text-3xl font-bold text-slate-800 mb-2">OJT Master</h1>
                <p className="text-slate-500">AI 기반 온보딩 교육 플랫폼</p>
                <p className="text-xs text-slate-400 mt-1">v2.6.4 (324dbf9) | Source State Fix</p>
                <p className="text-xs text-slate-400 mt-0.5 max-w-xs truncate" title="feat: R2 이미지 업로드 기능 추가 (#26)">feat: R2 이미지 업로드 기능 추가</p>
              </div>

              <div className="mb-6">
                <AIStatusBadge />
                {aiStatus.online && (
                  <p className="text-xs text-blue-600 mt-2">Google Gemini AI로 자료를 생성합니다</p>
                )}
              </div>

              <div className="space-y-4">
                <button
                  onClick={handleGoogleLogin}
                  className="w-full py-3 bg-white border-2 border-slate-200 text-slate-700 rounded-lg font-bold hover:bg-slate-50 hover:border-slate-300 transition-colors flex items-center justify-center gap-3"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                  </svg>
                  Google로 로그인
                </button>
                <p className="text-xs text-slate-400 mt-4">
                  Google 계정으로 안전하게 로그인하세요.
                </p>
              </div>
            </div>
          </div>
        );
      };

      const Header = () => {
        const getRoleBadgeColor = (role, isTemp) => {
          if (isTemp) return 'bg-amber-500 text-white';
          switch (role) {
            case 'admin': return 'bg-red-600 text-white';
            case 'mentor': return 'bg-indigo-800 text-indigo-100';
            case 'mentee': return 'bg-green-600 text-white';
            default: return 'bg-slate-600 text-white';
          }
        };

        const handleHomeClick = () => {
          // 임시 모드일 때는 해당 모드의 홈으로
          const effectiveRole = sessionMode || user?.role;
          if (effectiveRole === 'admin') setViewState('admin_dashboard');
          else if (effectiveRole === 'mentor') setViewState('mentor_dashboard');
          else if (effectiveRole === 'mentee') { setViewState('mentee_list'); setSelectedTeam(null); }
        };

        return (
          <header className="bg-indigo-600 text-white p-4 shadow-md flex justify-between items-center sticky top-0 z-50">
            <div className="flex items-center gap-2 cursor-pointer" onClick={handleHomeClick}>
              <Icon name="brain" className="w-8 h-8" />
              <div>
                <h1 className="text-xl font-bold">OJT Master <span className="text-xs font-normal text-indigo-200">v2.6.4</span></h1>
                <p className="text-xs text-indigo-200">
                  {user ? (
                    sessionMode
                      ? `${sessionMode.toUpperCase()} MODE (임시)`
                      : `${user.role?.toUpperCase()} MODE`
                  ) : 'Welcome'} | 68a5e30
                </p>
                <p className="text-xs text-indigo-300 opacity-70 truncate max-w-[200px]" title="feat: MentorDashboard 탭 기반 레이아웃으로 개선">탭 기반 레이아웃</p>
              </div>
            </div>
            <div className="flex items-center gap-3">
              <AIStatusBadge />
              {user && (
                <>
                  {/* Admin 모드 전환 버튼 */}
                  {user.role === 'admin' && (
                    <div className="relative mode-menu-container">
                      <button
                        onClick={() => setShowModeMenu(!showModeMenu)}
                        className="text-sm flex items-center gap-1 px-2 py-1 rounded hover:bg-indigo-700 transition border border-indigo-400"
                      >
                        <Icon name="settings" className="w-4 h-4" />
                        <span className="hidden sm:inline">모드</span>
                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                        </svg>
                      </button>
                      {showModeMenu && (
                        <div className="absolute right-0 mt-2 w-48 bg-white text-slate-800 rounded-lg shadow-xl z-50 py-1">
                          <button
                            onClick={() => handleModeSwitch(null)}
                            className={`w-full text-left px-4 py-2 hover:bg-slate-100 text-sm flex items-center gap-2 ${!sessionMode ? 'bg-slate-100 font-semibold' : ''}`}
                          >
                            <Icon name="shield" className="w-4 h-4 text-red-600" />
                            Admin 대시보드
                            {!sessionMode && <span className="ml-auto text-green-600">✓</span>}
                          </button>
                          <button
                            onClick={() => handleModeSwitch('mentor')}
                            className={`w-full text-left px-4 py-2 hover:bg-slate-100 text-sm flex items-center gap-2 ${sessionMode === 'mentor' ? 'bg-slate-100 font-semibold' : ''}`}
                          >
                            <Icon name="edit" className="w-4 h-4 text-indigo-600" />
                            Mentor 작업실
                            {sessionMode === 'mentor' && <span className="ml-auto text-green-600">✓</span>}
                          </button>
                          <hr className="my-1" />
                          <button
                            onClick={() => setShowModeMenu(false)}
                            className="w-full text-left px-4 py-2 hover:bg-slate-100 text-sm text-slate-500"
                          >
                            닫기
                          </button>
                        </div>
                      )}
                    </div>
                  )}
                  <span className="text-sm hidden sm:block">{user.name}</span>
                  <span className={`px-3 py-1 rounded-full text-xs font-bold uppercase ${getRoleBadgeColor(sessionMode || user.role, !!sessionMode)}`}>
                    {sessionMode || user.role}
                  </span>
                  <button onClick={handleLogout} className="text-sm flex items-center gap-1 hover:text-red-200">
                    <Icon name="logout" className="w-4 h-4" /> 로그아웃
                  </button>
                </>
              )}
            </div>
          </header>
        );
      };

      // =========================================
      // Admin Dashboard Component
      // =========================================
      const AdminDashboard = () => {
        const [adminTab, setAdminTab] = useState('users'); // 'users', 'content', 'departments', 'stats'
        const [allUsers, setAllUsers] = useState([]);
        const [allDocs, setAllDocs] = useState([]);
        const [allRecords, setAllRecords] = useState([]);
        const [allTeams, setAllTeams] = useState([]); // 부서 목록
        const [isLoading, setIsLoading] = useState(true);
        const [selectedUser, setSelectedUser] = useState(null);
        const [showRoleModal, setShowRoleModal] = useState(false);
        const [selectedDoc, setSelectedDoc] = useState(null); // 상세보기용 문서
        const [showDocModal, setShowDocModal] = useState(false); // 문서 상세 모달
        const [showTeamModal, setShowTeamModal] = useState(false); // 부서 추가/수정 모달
        const [editingTeam, setEditingTeam] = useState(null); // 수정 중인 부서
        const [newTeamName, setNewTeamName] = useState(''); // 새 부서명
        const [newTeamSlug, setNewTeamSlug] = useState(''); // 새 부서 slug
        const [newTeamDesc, setNewTeamDesc] = useState(''); // 새 부서 설명
        const chartRef = useRef(null);
        const chartInstance = useRef(null);

        // 데이터 로드
        useEffect(() => {
          const loadAdminData = async () => {
            setIsLoading(true);
            try {
              // 모든 사용자 조회 (Admin RLS 정책 적용)
              const { data: users, error: usersError } = await supabase
                .from('users')
                .select('*')
                .order('created_at', { ascending: false });

              if (usersError) throw usersError;
              setAllUsers(users || []);

              // 모든 문서 조회
              const { data: docs, error: docsError } = await supabase
                .from('ojt_docs')
                .select('*')
                .order('created_at', { ascending: false });

              if (docsError) throw docsError;
              setAllDocs(docs || []);

              // 모든 학습 기록 조회 (Admin RLS 정책 적용)
              const { data: records, error: recordsError } = await supabase
                .from('learning_records')
                .select('*')
                .order('completed_at', { ascending: false });

              if (!recordsError) setAllRecords(records || []);

              // 부서(teams) 목록 조회
              const { data: teams, error: teamsError } = await supabase
                .from('teams')
                .select('*')
                .order('display_order', { ascending: true });

              if (!teamsError) setAllTeams(teams || []);
            } catch (e) {
              console.error('Admin data load error:', e);
              Toast.error('관리자 데이터를 불러오는 중 오류가 발생했습니다.');
            } finally {
              setIsLoading(false);
            }
          };

          loadAdminData();
        }, []);

        // 차트 생성/업데이트
        useEffect(() => {
          if (adminTab === 'stats' && chartRef.current && allUsers.length > 0) {
            // 기존 차트 제거
            if (chartInstance.current) {
              chartInstance.current.destroy();
            }

            // 역할별 사용자 수 집계
            const roleCounts = allUsers.reduce((acc, user) => {
              acc[user.role] = (acc[user.role] || 0) + 1;
              return acc;
            }, {});

            const ctx = chartRef.current.getContext('2d');
            chartInstance.current = new Chart(ctx, {
              type: 'doughnut',
              data: {
                labels: ['관리자', '멘토', '멘티'],
                datasets: [{
                  data: [roleCounts.admin || 0, roleCounts.mentor || 0, roleCounts.mentee || 0],
                  backgroundColor: ['#dc2626', '#4f46e5', '#16a34a'],
                  borderWidth: 0
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { position: 'bottom' }
                }
              }
            });
          }

          return () => {
            if (chartInstance.current) {
              chartInstance.current.destroy();
            }
          };
        }, [adminTab, allUsers]);

        // 부서 변경 핸들러
        const handleDepartmentChange = async (userId, newDepartment) => {
          try {
            const { error } = await supabase
              .from('users')
              .update({ department: newDepartment || null, updated_at: Date.now() })
              .eq('id', userId);

            if (error) throw error;

            setAllUsers(prev => prev.map(u => u.id === userId ? { ...u, department: newDepartment || null } : u));
            Toast.success('부서가 변경되었습니다.');
          } catch (e) {
            console.error('Department change error:', e);
            Toast.error('부서 변경에 실패했습니다: ' + e.message);
          }
        };

        // 역할 변경 핸들러
        const handleRoleChange = async (userId, newRole) => {
          try {
            const { data, error } = await supabase
              .from('users')
              .update({ role: newRole })
              .eq('id', userId)
              .select();

            if (error) throw error;

            // RLS가 업데이트를 차단한 경우 (0행 반환)
            if (!data || data.length === 0) {
              throw new Error('권한이 없거나 RLS 정책에 의해 차단되었습니다. Supabase 대시보드에서 RLS 정책을 확인하세요.');
            }

            // 로컬 상태 업데이트
            setAllUsers(prev => prev.map(u => u.id === userId ? { ...u, role: newRole } : u));
            setShowRoleModal(false);
            setSelectedUser(null);
            Toast.success(`역할이 ${newRole}(으)로 변경되었습니다.`);
          } catch (e) {
            console.error('Role change error:', e);
            Toast.error('역할 변경에 실패했습니다: ' + e.message);
          }
        };

        // 문서 삭제 핸들러 (CSRF 방어 - 공통 헬퍼 사용)
        const handleDeleteDoc = async (docId) => {
          const doc = allDocs.find(d => d.id === docId);
          if (!doc) return;

          // CSRF 방어: 2단계 확인 (공통 헬퍼 사용)
          if (!confirmDeleteWithCSRF(doc.title)) return;

          try {
            const { error } = await supabase
              .from('ojt_docs')
              .delete()
              .eq('id', docId);

            if (error) throw error;

            setAllDocs(prev => prev.filter(d => d.id !== docId));
            Toast.success('문서가 삭제되었습니다.');
          } catch (e) {
            console.error('Delete doc error:', e);
            Toast.error('문서 삭제에 실패했습니다: ' + e.message);
          }
        };

        // 부서 추가/수정 모달 열기
        const openTeamModal = (team = null) => {
          if (team) {
            setEditingTeam(team);
            setNewTeamName(team.name);
            setNewTeamSlug(team.slug || '');
            setNewTeamDesc(team.description || '');
          } else {
            setEditingTeam(null);
            setNewTeamName('');
            setNewTeamSlug('');
            setNewTeamDesc('');
          }
          setShowTeamModal(true);
        };

        // 부서명에서 slug 자동 생성
        const generateSlug = (name) => {
          return name
            .toLowerCase()
            .replace(/[^a-z0-9가-힣\s]/g, '')
            .replace(/\s+/g, '_')
            .substring(0, 50);
        };

        // 부서 저장 (추가/수정)
        const handleSaveTeam = async () => {
          if (!newTeamName.trim()) {
            Toast.error('부서명을 입력해주세요.');
            return;
          }

          const slug = newTeamSlug.trim() || generateSlug(newTeamName);

          try {
            if (editingTeam) {
              // 수정
              const { error } = await supabase
                .from('teams')
                .update({
                  name: newTeamName.trim(),
                  slug: slug,
                  description: newTeamDesc.trim() || null
                })
                .eq('id', editingTeam.id);

              if (error) throw error;

              setAllTeams(prev => prev.map(t =>
                t.id === editingTeam.id
                  ? { ...t, name: newTeamName.trim(), slug, description: newTeamDesc.trim() || null }
                  : t
              ));
              Toast.success('부서가 수정되었습니다.');
            } else {
              // 추가
              const maxOrder = allTeams.length > 0 ? Math.max(...allTeams.map(t => t.display_order || 0)) : 0;
              const { data, error } = await supabase
                .from('teams')
                .insert({
                  name: newTeamName.trim(),
                  slug: slug,
                  description: newTeamDesc.trim() || null,
                  display_order: maxOrder + 1,
                  is_active: true
                })
                .select()
                .single();

              if (error) throw error;

              setAllTeams(prev => [...prev, data]);
              Toast.success('부서가 추가되었습니다.');
            }

            setShowTeamModal(false);
            setEditingTeam(null);
            setNewTeamName('');
            setNewTeamSlug('');
            setNewTeamDesc('');
          } catch (e) {
            console.error('Save team error:', e);
            Toast.error('부서 저장에 실패했습니다: ' + e.message);
          }
        };

        // 부서 삭제
        const handleDeleteTeam = async (teamId) => {
          const team = allTeams.find(t => t.id === teamId);
          if (!team) return;

          // 해당 부서에 속한 문서 수 확인
          const docsInTeam = allDocs.filter(d => d.team === team.name || d.team_id === teamId).length;
          if (docsInTeam > 0) {
            Toast.error(`이 부서에 ${docsInTeam}개의 문서가 있어 삭제할 수 없습니다.`);
            return;
          }

          if (!confirmDeleteWithCSRF(team.name)) return;

          try {
            const { error } = await supabase
              .from('teams')
              .delete()
              .eq('id', teamId);

            if (error) throw error;

            setAllTeams(prev => prev.filter(t => t.id !== teamId));
            Toast.success('부서가 삭제되었습니다.');
          } catch (e) {
            console.error('Delete team error:', e);
            Toast.error('부서 삭제에 실패했습니다: ' + e.message);
          }
        };

        // 부서 활성화/비활성화 토글
        const handleToggleTeamActive = async (teamId, currentStatus) => {
          try {
            const { error } = await supabase
              .from('teams')
              .update({ is_active: !currentStatus })
              .eq('id', teamId);

            if (error) throw error;

            setAllTeams(prev => prev.map(t =>
              t.id === teamId ? { ...t, is_active: !currentStatus } : t
            ));
            Toast.success(currentStatus ? '부서가 비활성화되었습니다.' : '부서가 활성화되었습니다.');
          } catch (e) {
            console.error('Toggle team active error:', e);
            Toast.error('상태 변경에 실패했습니다: ' + e.message);
          }
        };

        // 통계 계산
        const stats = useMemo(() => {
          const totalUsers = allUsers.length;
          const totalDocs = allDocs.length;
          const totalRecords = allRecords.length;
          const passedRecords = allRecords.filter(r => r.passed).length;
          const passRate = totalRecords > 0 ? Math.round((passedRecords / totalRecords) * 100) : 0;

          return { totalUsers, totalDocs, totalRecords, passRate };
        }, [allUsers, allDocs, allRecords]);

        if (isLoading) {
          return (
            <div className="flex items-center justify-center min-h-[calc(100vh-80px)]">
              <div className="text-center">
                <div className="w-12 h-12 border-4 border-indigo-600 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                <p className="text-slate-600">관리자 데이터를 불러오는 중...</p>
              </div>
            </div>
          );
        }

        return (
          <div className="max-w-7xl mx-auto px-4 py-8">
            <h2 className="text-2xl font-bold text-slate-800 mb-6 flex items-center gap-2">
              <Icon name="settings" className="w-7 h-7 text-red-600" />
              관리자 대시보드
            </h2>

            {/* 통계 카드 */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
              <div className="bg-white rounded-xl shadow p-6">
                <p className="text-sm text-slate-500">전체 사용자</p>
                <p className="text-3xl font-bold text-slate-800">{stats.totalUsers}</p>
              </div>
              <div className="bg-white rounded-xl shadow p-6">
                <p className="text-sm text-slate-500">전체 문서</p>
                <p className="text-3xl font-bold text-indigo-600">{stats.totalDocs}</p>
              </div>
              <div className="bg-white rounded-xl shadow p-6">
                <p className="text-sm text-slate-500">학습 기록</p>
                <p className="text-3xl font-bold text-green-600">{stats.totalRecords}</p>
              </div>
              <div className="bg-white rounded-xl shadow p-6">
                <p className="text-sm text-slate-500">퀴즈 통과율</p>
                <p className="text-3xl font-bold text-amber-600">{stats.passRate}%</p>
              </div>
            </div>

            {/* 탭 네비게이션 */}
            <div className="flex gap-2 mb-6 border-b border-slate-200 overflow-x-auto">
              <button
                onClick={() => setAdminTab('users')}
                className={`px-4 py-2 font-medium transition-colors whitespace-nowrap ${adminTab === 'users' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-slate-500 hover:text-slate-700'}`}
              >
                <Icon name="user" className="w-4 h-4 inline mr-1" /> 사용자 관리
              </button>
              <button
                onClick={() => setAdminTab('content')}
                className={`px-4 py-2 font-medium transition-colors whitespace-nowrap ${adminTab === 'content' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-slate-500 hover:text-slate-700'}`}
              >
                <Icon name="book" className="w-4 h-4 inline mr-1" /> 콘텐츠 관리
              </button>
              <button
                onClick={() => setAdminTab('departments')}
                className={`px-4 py-2 font-medium transition-colors whitespace-nowrap ${adminTab === 'departments' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-slate-500 hover:text-slate-700'}`}
              >
                <Icon name="box" className="w-4 h-4 inline mr-1" /> 부서 관리
              </button>
              <button
                onClick={() => setAdminTab('stats')}
                className={`px-4 py-2 font-medium transition-colors whitespace-nowrap ${adminTab === 'stats' ? 'text-indigo-600 border-b-2 border-indigo-600' : 'text-slate-500 hover:text-slate-700'}`}
              >
                <Icon name="server" className="w-4 h-4 inline mr-1" /> 통계
              </button>
            </div>

            {/* 사용자 관리 탭 */}
            {adminTab === 'users' && (
              <div className="bg-white rounded-xl shadow overflow-hidden">
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead className="bg-slate-50">
                      <tr>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">이름</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">역할</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">부서</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">가입일</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">작업</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                      {allUsers.map(u => (
                        <tr key={u.id} className="hover:bg-slate-50">
                          <td className="px-4 py-3 text-sm font-medium text-slate-800">{u.name}</td>
                          <td className="px-4 py-3">
                            <span className={`px-2 py-1 rounded-full text-xs font-bold uppercase ${
                              u.role === 'admin' ? 'bg-red-100 text-red-700' :
                              u.role === 'mentor' ? 'bg-indigo-100 text-indigo-700' :
                              'bg-green-100 text-green-700'
                            }`}>
                              {u.role}
                            </span>
                          </td>
                          <td className="px-4 py-3">
                            <select
                              value={u.department || ''}
                              onChange={(e) => handleDepartmentChange(u.id, e.target.value)}
                              className="px-2 py-1 text-sm border border-slate-200 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500"
                            >
                              <option value="">부서 선택</option>
                              {[...new Set(allDocs.map(d => d.team).filter(Boolean))].sort().map(team => (
                                <option key={team} value={team}>{team}</option>
                              ))}
                            </select>
                          </td>
                          <td className="px-4 py-3 text-sm text-slate-500">
                            {new Date(u.created_at).toLocaleDateString('ko-KR')}
                          </td>
                          <td className="px-4 py-3">
                            <button
                              onClick={() => { setSelectedUser(u); setShowRoleModal(true); }}
                              className="text-indigo-600 hover:text-indigo-800 text-sm font-medium"
                              disabled={u.id === user.id}
                            >
                              역할 변경
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                {allUsers.length === 0 && (
                  <div className="text-center py-8 text-slate-500">사용자가 없습니다.</div>
                )}
              </div>
            )}

            {/* 콘텐츠 관리 탭 */}
            {adminTab === 'content' && (
              <div className="bg-white rounded-xl shadow overflow-hidden">
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead className="bg-slate-50">
                      <tr>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">제목</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">팀</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">스텝</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">작성자</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">생성일</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">작업</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                      {allDocs.map(doc => (
                        <tr key={doc.id} className="hover:bg-slate-50">
                          <td className="px-4 py-3 text-sm font-medium text-slate-800">{doc.title}</td>
                          <td className="px-4 py-3 text-sm text-slate-600">{doc.team}</td>
                          <td className="px-4 py-3 text-sm text-slate-600">Step {doc.step}</td>
                          <td className="px-4 py-3 text-sm text-slate-600">{doc.author_name || '-'}</td>
                          <td className="px-4 py-3 text-sm text-slate-500">
                            {new Date(doc.created_at).toLocaleDateString('ko-KR')}
                          </td>
                          <td className="px-4 py-3">
                            <div className="flex gap-2">
                              <button
                                onClick={() => { setSelectedDoc(doc); setShowDocModal(true); }}
                                className="text-indigo-600 hover:text-indigo-800 text-sm font-medium"
                              >
                                보기
                              </button>
                              <button
                                onClick={() => {
                                  // Mentor 모드로 전환 후 편집
                                  SecureSession.set('ojt_sessionMode', 'mentor');
                                  setSessionMode('mentor');
                                  // 문서를 에디터에 로드
                                  const mappedDoc = {
                                    ...doc,
                                    authorId: doc.author_id,
                                    author: doc.author_name,
                                    estimatedMinutes: doc.estimated_minutes,
                                    createdAt: new Date(doc.created_at).getTime()
                                  };
                                  handleEditDoc(mappedDoc);
                                  setViewState('mentor_dashboard');
                                }}
                                className="text-green-600 hover:text-green-800 text-sm font-medium"
                              >
                                편집
                              </button>
                              <button
                                onClick={() => handleDeleteDoc(doc.id)}
                                className="text-red-600 hover:text-red-800 text-sm font-medium"
                              >
                                삭제
                              </button>
                            </div>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                {allDocs.length === 0 && (
                  <div className="text-center py-8 text-slate-500">문서가 없습니다.</div>
                )}
              </div>
            )}

            {/* 문서 상세보기 모달 */}
            {showDocModal && selectedDoc && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-2xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden">
                  <div className="p-6 border-b border-slate-200 flex justify-between items-start">
                    <div>
                      <h3 className="text-xl font-bold text-slate-800">{selectedDoc.title}</h3>
                      <div className="flex gap-2 mt-2">
                        <span className="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded">{selectedDoc.team}</span>
                        <span className="text-xs bg-slate-100 text-slate-700 px-2 py-1 rounded">Step {selectedDoc.step}</span>
                        <span className="text-xs bg-slate-100 text-slate-600 px-2 py-1 rounded">작성자: {selectedDoc.author_name || '-'}</span>
                      </div>
                    </div>
                    <button
                      onClick={() => setShowDocModal(false)}
                      className="text-slate-400 hover:text-slate-600 text-2xl leading-none"
                    >
                      &times;
                    </button>
                  </div>
                  <div className="p-6 overflow-y-auto max-h-[60vh]">
                    {selectedDoc.sections && selectedDoc.sections.map((section, idx) => (
                      <div key={idx} className="mb-6">
                        <h4 className="text-lg font-semibold text-slate-800 mb-2 flex items-center gap-2">
                          <span className="w-6 h-6 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center text-sm font-bold">{idx + 1}</span>
                          {section.title}
                        </h4>
                        <div className="text-slate-600 text-sm whitespace-pre-wrap bg-slate-50 p-4 rounded-lg">
                          {section.content || '내용 없음'}
                        </div>
                      </div>
                    ))}
                    {selectedDoc.quiz && selectedDoc.quiz.length > 0 && (
                      <div className="mt-6 pt-6 border-t border-slate-200">
                        <h4 className="text-lg font-semibold text-slate-800 mb-3">퀴즈 ({selectedDoc.quiz.length}문제)</h4>
                        <div className="space-y-3">
                          {selectedDoc.quiz.slice(0, 5).map((q, idx) => (
                            <div key={idx} className="bg-amber-50 p-3 rounded-lg">
                              <p className="text-sm font-medium text-slate-800">Q{idx + 1}. {q.question}</p>
                              <p className="text-xs text-green-600 mt-1">정답: {q.answer}</p>
                            </div>
                          ))}
                          {selectedDoc.quiz.length > 5 && (
                            <p className="text-xs text-slate-500">... 외 {selectedDoc.quiz.length - 5}문제</p>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                  <div className="p-4 border-t border-slate-200 flex justify-end gap-2">
                    <button
                      onClick={() => {
                        setShowDocModal(false);
                        // Mentor 모드로 전환 후 편집
                        SecureSession.set('ojt_sessionMode', 'mentor');
                        setSessionMode('mentor');
                        const mappedDoc = {
                          ...selectedDoc,
                          authorId: selectedDoc.author_id,
                          author: selectedDoc.author_name,
                          estimatedMinutes: selectedDoc.estimated_minutes,
                          createdAt: new Date(selectedDoc.created_at).getTime()
                        };
                        handleEditDoc(mappedDoc);
                        setViewState('mentor_dashboard');
                      }}
                      className="px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-medium hover:bg-indigo-700"
                    >
                      편집하기
                    </button>
                    <button
                      onClick={() => setShowDocModal(false)}
                      className="px-4 py-2 bg-slate-100 text-slate-600 rounded-lg text-sm font-medium hover:bg-slate-200"
                    >
                      닫기
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* 부서 관리 탭 */}
            {adminTab === 'departments' && (
              <div className="bg-white rounded-xl shadow overflow-hidden">
                <div className="p-4 border-b border-slate-200 flex justify-between items-center">
                  <h3 className="text-lg font-semibold text-slate-800">부서 목록</h3>
                  <button
                    onClick={() => openTeamModal()}
                    className="px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-medium hover:bg-indigo-700 flex items-center gap-1"
                  >
                    <Icon name="plus" className="w-4 h-4" /> 부서 추가
                  </button>
                </div>
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead className="bg-slate-50">
                      <tr>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">부서명</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">Slug</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">설명</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">문서 수</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">상태</th>
                        <th className="px-4 py-3 text-left text-xs font-semibold text-slate-600 uppercase">작업</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                      {allTeams.map(team => {
                        const docCount = allDocs.filter(d => d.team === team.name || d.team_id === team.id).length;
                        return (
                          <tr key={team.id} className="hover:bg-slate-50">
                            <td className="px-4 py-3 text-sm font-medium text-slate-800">{team.name}</td>
                            <td className="px-4 py-3 text-sm text-slate-500 font-mono">{team.slug}</td>
                            <td className="px-4 py-3 text-sm text-slate-600">{team.description || '-'}</td>
                            <td className="px-4 py-3 text-sm text-slate-600">{docCount}개</td>
                            <td className="px-4 py-3">
                              <button
                                onClick={() => handleToggleTeamActive(team.id, team.is_active)}
                                className={`px-2 py-1 rounded-full text-xs font-bold ${
                                  team.is_active
                                    ? 'bg-green-100 text-green-700 hover:bg-green-200'
                                    : 'bg-slate-100 text-slate-500 hover:bg-slate-200'
                                }`}
                              >
                                {team.is_active ? '활성' : '비활성'}
                              </button>
                            </td>
                            <td className="px-4 py-3">
                              <div className="flex gap-2">
                                <button
                                  onClick={() => openTeamModal(team)}
                                  className="text-indigo-600 hover:text-indigo-800 text-sm font-medium"
                                >
                                  수정
                                </button>
                                <button
                                  onClick={() => handleDeleteTeam(team.id)}
                                  className="text-red-600 hover:text-red-800 text-sm font-medium"
                                  disabled={docCount > 0}
                                  title={docCount > 0 ? '문서가 있는 부서는 삭제할 수 없습니다' : ''}
                                >
                                  삭제
                                </button>
                              </div>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
                {allTeams.length === 0 && (
                  <div className="text-center py-8 text-slate-500">
                    부서가 없습니다. 상단의 "부서 추가" 버튼을 클릭하여 부서를 생성하세요.
                  </div>
                )}
              </div>
            )}

            {/* 부서 추가/수정 모달 */}
            {showTeamModal && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-xl shadow-xl p-6 w-full max-w-md">
                  <h3 className="text-lg font-semibold text-slate-800 mb-4">
                    {editingTeam ? '부서 수정' : '부서 추가'}
                  </h3>
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium text-slate-700 mb-1">부서명 *</label>
                      <input
                        type="text"
                        value={newTeamName}
                        onChange={(e) => {
                          setNewTeamName(e.target.value);
                          if (!editingTeam && !newTeamSlug) {
                            // 신규 생성 시 slug 자동 생성 (직접 입력 전까지만)
                          }
                        }}
                        placeholder="예: 개발팀"
                        className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-slate-700 mb-1">Slug (URL용)</label>
                      <input
                        type="text"
                        value={newTeamSlug}
                        onChange={(e) => setNewTeamSlug(e.target.value.toLowerCase().replace(/[^a-z0-9_]/g, ''))}
                        placeholder="예: dev (자동 생성됨)"
                        className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 font-mono"
                      />
                      <p className="text-xs text-slate-500 mt-1">비워두면 부서명에서 자동 생성됩니다.</p>
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-slate-700 mb-1">설명</label>
                      <textarea
                        value={newTeamDesc}
                        onChange={(e) => setNewTeamDesc(e.target.value)}
                        placeholder="부서에 대한 간단한 설명"
                        rows={2}
                        className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                      />
                    </div>
                  </div>
                  <div className="flex gap-2 mt-6">
                    <button
                      onClick={handleSaveTeam}
                      className="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-lg font-medium hover:bg-indigo-700"
                    >
                      {editingTeam ? '수정' : '추가'}
                    </button>
                    <button
                      onClick={() => {
                        setShowTeamModal(false);
                        setEditingTeam(null);
                        setNewTeamName('');
                        setNewTeamSlug('');
                        setNewTeamDesc('');
                      }}
                      className="flex-1 px-4 py-2 bg-slate-200 text-slate-700 rounded-lg font-medium hover:bg-slate-300"
                    >
                      취소
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* 통계 탭 */}
            {adminTab === 'stats' && (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="bg-white rounded-xl shadow p-6">
                  <h3 className="text-lg font-semibold text-slate-800 mb-4">역할별 사용자 분포</h3>
                  <div className="w-64 h-64 mx-auto">
                    <canvas ref={chartRef}></canvas>
                  </div>
                </div>
                <div className="bg-white rounded-xl shadow p-6">
                  <h3 className="text-lg font-semibold text-slate-800 mb-4">팀별 문서 현황</h3>
                  <div className="space-y-3">
                    {Object.entries(
                      allDocs.reduce((acc, doc) => {
                        acc[doc.team] = (acc[doc.team] || 0) + 1;
                        return acc;
                      }, {})
                    ).map(([team, count]) => (
                      <div key={team} className="flex items-center justify-between">
                        <span className="text-sm text-slate-600">{team}</span>
                        <div className="flex items-center gap-2">
                          <div className="w-32 bg-slate-200 rounded-full h-2">
                            <div
                              className="bg-indigo-600 h-2 rounded-full"
                              style={{ width: `${Math.min((count / allDocs.length) * 100, 100)}%` }}
                            ></div>
                          </div>
                          <span className="text-sm font-medium text-slate-800">{count}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}

            {/* 역할 변경 모달 */}
            {showRoleModal && selectedUser && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div className="bg-white rounded-xl shadow-xl p-6 w-full max-w-md">
                  <h3 className="text-lg font-semibold text-slate-800 mb-4">역할 변경</h3>
                  <p className="text-sm text-slate-600 mb-4">
                    <strong>{selectedUser.name}</strong>님의 역할을 변경합니다.
                  </p>
                  <div className="grid grid-cols-3 gap-2 mb-6">
                    {['admin', 'mentor', 'mentee'].map(role => (
                      <button
                        key={role}
                        onClick={() => handleRoleChange(selectedUser.id, role)}
                        disabled={selectedUser.role === role}
                        className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
                          selectedUser.role === role
                            ? 'bg-slate-100 text-slate-400 cursor-not-allowed'
                            : role === 'admin'
                            ? 'bg-red-100 text-red-700 hover:bg-red-200'
                            : role === 'mentor'
                            ? 'bg-indigo-100 text-indigo-700 hover:bg-indigo-200'
                            : 'bg-green-100 text-green-700 hover:bg-green-200'
                        }`}
                      >
                        {role.toUpperCase()}
                      </button>
                    ))}
                  </div>
                  <button
                    onClick={() => { setShowRoleModal(false); setSelectedUser(null); }}
                    className="w-full px-4 py-2 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300"
                  >
                    취소
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      };

      const RoleSelectionPage = () => (
        <div className="flex flex-col items-center justify-center min-h-[calc(100vh-80px)] bg-slate-50 p-6">
          <div className="max-w-3xl w-full bg-white rounded-2xl shadow-xl p-8 text-center">
            <Icon name="user" className="w-16 h-16 text-indigo-600 mx-auto mb-4" />
            <h2 className="text-3xl font-bold text-slate-800 mb-2">환영합니다, {user?.name}!</h2>
            <p className="text-slate-500 mb-8">서비스 이용을 위해 역할을 선택해주세요.</p>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <button
                onClick={() => handleRoleSelect('mentor')}
                className="group flex flex-col items-center p-8 border-2 border-slate-200 rounded-xl hover:border-indigo-500 hover:bg-indigo-50 transition-all"
              >
                <div className="w-16 h-16 bg-indigo-100 rounded-full flex items-center justify-center mb-4 group-hover:scale-110 transition-transform">
                  <Icon name="upload" className="w-8 h-8 text-indigo-600" />
                </div>
                <h3 className="text-xl font-bold text-slate-700">멘토 (Mentor)</h3>
                <p className="text-slate-500 mt-2 text-sm">OJT 자료를 생성하고<br />교육 과정을 관리합니다.</p>
              </button>

              <button
                onClick={() => handleRoleSelect('mentee')}
                className="group flex flex-col items-center p-8 border-2 border-slate-200 rounded-xl hover:border-green-500 hover:bg-green-50 transition-all"
              >
                <div className="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mb-4 group-hover:scale-110 transition-transform">
                  <Icon name="book" className="w-8 h-8 text-green-600" />
                </div>
                <h3 className="text-xl font-bold text-slate-700">멘티 (Mentee)</h3>
                <p className="text-slate-500 mt-2 text-sm">공개된 교육 자료를 학습하고<br />퀴즈로 이해도를 검증합니다.</p>
              </button>
            </div>
          </div>
        </div>
      );

      const mentorDashboardContent = (
        <div className="max-w-6xl mx-auto p-6">
          <h2 className="text-2xl font-bold text-slate-800 flex items-center gap-2 mb-4">
            <Icon name="upload" className="w-6 h-6 text-indigo-600" />
            {editingDoc ? '문서 수정' : '자료 생성 스튜디오'}
          </h2>

          {/* 편집 모드 배너 */}
          {editingDoc && (
            <div className="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg flex items-center justify-between">
              <div className="flex items-center gap-3">
                <Icon name="edit" className="w-5 h-5 text-blue-600" />
                <div>
                  <p className="font-semibold text-blue-800">편집 모드: {editingDoc.title}</p>
                  <p className="text-sm text-blue-600">{editingDoc.team} - Step {editingDoc.step}</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                {editingDoc.quiz?.length > 0 && (
                  <button
                    onClick={() => setShowQuizPreview(true)}
                    className="text-xs bg-indigo-100 text-indigo-700 px-3 py-1 rounded-full hover:bg-indigo-200 transition"
                  >
                    퀴즈 미리보기/수정 ({editingDoc.quiz.length}문제)
                  </button>
                )}
                <button
                  onClick={handleCancelEdit}
                  className="text-blue-600 hover:text-blue-800 text-sm font-semibold px-3 py-1 rounded hover:bg-blue-100"
                >
                  편집 취소
                </button>
              </div>
            </div>
          )}

          {!aiStatus.online && (
            <div className="mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg flex items-start gap-3">
              <Icon name="alert" className="w-5 h-5 text-yellow-600 flex-shrink-0 mt-0.5" />
              <div>
                <p className="font-bold text-yellow-800">Gemini AI 연결 확인 중...</p>
                <p className="text-sm text-yellow-700 mt-1">
                  Google Gemini AI에 연결을 시도하고 있습니다.<br />
                  API 키가 올바른지 확인해주세요.
                </p>
              </div>
            </div>
          )}

          {/* 탭 UI - 편집/미리보기 전환 */}
          <div className="flex gap-2 mb-4 border-b border-slate-200 pb-3">
            <button
              onClick={() => setEditorTab('edit')}
              className={`flex items-center gap-2 px-5 py-2.5 rounded-lg text-sm font-bold transition-all ${
                editorTab === 'edit'
                  ? 'bg-indigo-600 text-white shadow-md'
                  : 'bg-white text-slate-600 hover:bg-slate-100 border border-slate-200'
              }`}
            >
              <Icon name="edit" className="w-4 h-4" />
              편집
            </button>
            <button
              onClick={() => setEditorTab('preview')}
              className={`flex items-center gap-2 px-5 py-2.5 rounded-lg text-sm font-bold transition-all ${
                editorTab === 'preview'
                  ? 'bg-indigo-600 text-white shadow-md'
                  : 'bg-white text-slate-600 hover:bg-slate-100 border border-slate-200'
              }`}
            >
              <Icon name="eye" className="w-4 h-4" />
              미리보기
              {(generatedDoc || generatedDocs.length > 0) && (
                <span className="ml-1 w-2 h-2 bg-green-400 rounded-full animate-pulse" />
              )}
            </button>
          </div>

          {/* 편집 탭 */}
          {editorTab === 'edit' && (
            <div className="flex flex-col gap-4 bg-white p-6 rounded-xl shadow-sm border border-slate-200">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="block text-xs font-bold text-slate-500 mb-1">대상 팀</label>
                  {!isCustomTeam ? (
                    <select
                      value={inputTeam}
                      onChange={(e) => { e.target.value === 'custom' ? (setIsCustomTeam(true), setInputTeam('')) : setInputTeam(e.target.value) }}
                      className="w-full p-2 border border-slate-300 rounded-lg text-sm bg-indigo-50"
                    >
                      {TEAMS.map(team => <option key={team} value={team}>{team}</option>)}
                      <option value="custom">+ 직접 입력</option>
                    </select>
                  ) : (
                    <div className="flex gap-2">
                      <input type="text" value={inputTeam} onChange={(e) => setInputTeam(e.target.value)} className="w-full p-2 border rounded-lg text-sm" autoFocus />
                      <button onClick={() => { setIsCustomTeam(false); setInputTeam(TEAMS[0]); }} className="p-2 bg-slate-200 rounded"><Icon name="refresh" className="w-4 h-4" /></button>
                    </div>
                  )}
                </div>
                <div>
                  <label className="block text-xs font-bold text-slate-500 mb-1">단계</label>
                  {!isCustomStep ? (
                    <select
                      value={inputStep}
                      onChange={(e) => { e.target.value === 'custom' ? (setIsCustomStep(true), setInputStep('')) : setInputStep(e.target.value) }}
                      className="w-full p-2 border border-slate-300 rounded-lg text-sm bg-indigo-50"
                    >
                      {STEPS.map(step => <option key={step} value={step}>Step {step}</option>)}
                      <option value="custom">+ 직접 입력</option>
                    </select>
                  ) : (
                    <div className="flex gap-2">
                      <input type="number" value={inputStep} onChange={(e) => setInputStep(e.target.value)} className="w-full p-2 border rounded-lg text-sm" autoFocus />
                      <button onClick={() => { setIsCustomStep(false); setInputStep(1); }} className="p-2 bg-slate-200 rounded"><Icon name="refresh" className="w-4 h-4" /></button>
                    </div>
                  )}
                </div>
              </div>
              <input type="text" placeholder="제목 (선택사항 - AI가 자동 생성)" className="w-full p-3 border rounded-lg" value={inputTitle} onChange={(e) => setInputTitle(e.target.value)} />

              {/* 자동 분할 옵션 */}
              <div className={`flex items-center justify-between p-3 rounded-lg border ${editingDoc ? 'bg-slate-100 border-slate-300' : 'bg-slate-50 border-slate-200'}`}>
                <div className="flex items-center gap-2">
                  <Icon name="split" className={`w-5 h-5 ${editingDoc ? 'text-slate-400' : 'text-indigo-600'}`} />
                  <div>
                    <p className={`text-sm font-medium ${editingDoc ? 'text-slate-500' : 'text-slate-700'}`}>자동 스텝 분할</p>
                    <p className="text-xs text-slate-500">
                      {editingDoc
                        ? '편집 모드에서는 자동 분할을 사용할 수 없습니다'
                        : '40분 이상 분량은 자동으로 여러 스텝으로 나눕니다'}
                    </p>
                  </div>
                </div>
                <button
                  onClick={() => !editingDoc && setAutoSplit(!autoSplit)}
                  disabled={!!editingDoc}
                  className={`relative w-12 h-6 rounded-full transition-colors ${
                    editingDoc
                      ? 'bg-slate-300 cursor-not-allowed'
                      : autoSplit ? 'bg-indigo-600' : 'bg-slate-300'
                  }`}
                  title={editingDoc ? '편집 모드에서는 사용 불가' : ''}
                >
                  <span className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-transform ${autoSplit && !editingDoc ? 'left-7' : 'left-1'}`} />
                </button>
              </div>

              {/* 예상 학습 시간 표시 */}
              {rawInput && (
                <div className={`flex items-center gap-3 p-3 rounded-lg border ${
                  estimatedTime > STEP_TIME_LIMIT
                    ? 'bg-amber-50 border-amber-200'
                    : 'bg-green-50 border-green-200'
                }`}>
                  <Icon name="clock" className={`w-5 h-5 ${estimatedTime > STEP_TIME_LIMIT ? 'text-amber-600' : 'text-green-600'}`} />
                  <div className="flex-1">
                    <p className={`text-sm font-medium ${estimatedTime > STEP_TIME_LIMIT ? 'text-amber-800' : 'text-green-800'}`}>
                      예상 학습 시간: 약 {estimatedTime}분
                    </p>
                    {requiredSteps > 1 && autoSplit && (
                      <p className="text-xs text-slate-600">
                        <Icon name="layers" className="w-3 h-3 inline mr-1" />
                        자동으로 {requiredSteps}개 스텝으로 분할됩니다 (스텝당 약 {Math.ceil(estimatedTime / requiredSteps)}분)
                      </p>
                    )}
                    {requiredSteps > 1 && !autoSplit && (
                      <p className="text-xs text-amber-600">
                        ⚠️ 40분 초과 분량입니다. 자동 분할을 권장합니다.
                      </p>
                    )}
                  </div>
                </div>
              )}

              {/* 입력 타입 선택 */}
              <div className="flex gap-2 border-b border-slate-200 pb-2">
                {INPUT_TYPES.map(type => (
                  <button
                    key={type.id}
                    onClick={() => setInputType(type.id)}
                    className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
                      inputType === type.id
                        ? 'bg-indigo-600 text-white'
                        : 'bg-slate-100 text-slate-600 hover:bg-slate-200'
                    }`}
                  >
                    <Icon name={type.icon} className="w-4 h-4" />
                    {type.label}
                  </button>
                ))}
              </div>

              {/* 입력 타입별 UI */}
              {inputType === 'text' && (
                <div className="border border-slate-300 rounded-lg overflow-hidden relative">
                  <div ref={quillRef} />
                  {/* 이미지 업로드 로딩 오버레이 */}
                  {isUploadingImage && (
                    <div className="absolute inset-0 bg-white/80 flex items-center justify-center z-10">
                      <div className="flex flex-col items-center gap-2">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                        <span className="text-sm text-slate-600">이미지 업로드 중...</span>
                      </div>
                    </div>
                  )}
                </div>
              )}

              {inputType === 'url' && (
                <div className="space-y-3">
                  <div className="flex gap-2">
                    <div className="flex-1 relative">
                      <Icon name="globe" className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-400" />
                      <input
                        type="url"
                        placeholder="https://example.com/article"
                        value={urlInput}
                        onChange={(e) => setUrlInput(e.target.value)}
                        className="w-full pl-10 p-3 border rounded-lg"
                      />
                    </div>
                  </div>
                  <p className="text-xs text-slate-500">
                    🚀 Gemini URL Context Tool로 원문을 직접 분석하여 퀴즈를 생성합니다. 원문은 그대로 보존됩니다.
                  </p>
                </div>
              )}

              {inputType === 'pdf' && (
                <div className="space-y-3">
                  <label className="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed border-slate-300 rounded-lg cursor-pointer hover:bg-slate-50 transition-colors">
                    <div className="flex flex-col items-center justify-center pt-5 pb-6">
                      <Icon name="file" className="w-10 h-10 mb-3 text-slate-400" />
                      {pdfFile ? (
                        <p className="text-sm text-indigo-600 font-medium">{pdfFile.name}</p>
                      ) : (
                        <>
                          <p className="mb-2 text-sm text-slate-500">
                            <span className="font-semibold">클릭하여 PDF 선택</span>
                          </p>
                          <p className="text-xs text-slate-400">PDF 파일만 지원</p>
                        </>
                      )}
                    </div>
                    <input
                      type="file"
                      accept=".pdf"
                      className="hidden"
                      onChange={(e) => setPdfFile(e.target.files?.[0] || null)}
                    />
                  </label>
                  {pdfFile && (
                    <>
                      <button
                        onClick={() => setPdfFile(null)}
                        className="text-sm text-red-500 hover:text-red-700"
                      >
                        파일 제거
                      </button>
                      <p className="text-xs text-slate-500">
                        🚀 PDF가 R2에 업로드되고, Gemini URL Context Tool로 분석하여 퀴즈를 생성합니다.
                      </p>
                    </>
                  )}
                </div>
              )}

              <button
                onClick={handleGenerate}
                disabled={isProcessing || !aiStatus.online ||
                  (inputType === 'text' && !rawInput) ||
                  (inputType === 'url' && !urlInput) ||
                  (inputType === 'pdf' && !pdfFile)
                }
                className="w-full py-3 bg-indigo-600 text-white rounded-lg font-bold disabled:bg-slate-400 hover:bg-indigo-700 transition-colors"
              >
                {isProcessing ? processingStatus || "생성 중..." : `AI 자료 생성 (${GEMINI_MODEL})`}
              </button>
            </div>
          )}

          {/* 미리보기 탭 */}
          {editorTab === 'preview' && (
            <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
              <div className="sticky top-0 bg-white pb-4 border-b border-slate-200 z-10">
                <div className="flex justify-between items-center">
                  <div className="flex items-center gap-3">
                    <button
                      onClick={() => setEditorTab('edit')}
                      className="flex items-center gap-1 text-sm text-slate-500 hover:text-indigo-600 transition-colors"
                    >
                      <Icon name="edit" className="w-4 h-4" />
                      편집으로
                    </button>
                    <h3 className="font-semibold text-slate-700">
                      미리보기
                      {generatedDocs.length > 1 && (
                        <span className="ml-2 text-xs font-normal text-indigo-600">
                          ({generatedDocs.length}개 스텝 생성됨)
                        </span>
                      )}
                    </h3>
                  </div>
                  {(generatedDoc || generatedDocs.length > 0) && (
                    <button onClick={handleSaveToDB} className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg font-bold text-sm hover:bg-green-700">
                      <Icon name="save" className="w-4 h-4" />
                      {editingDoc ? '수정 저장' : (generatedDocs.length > 1 ? `${generatedDocs.length}개 모두 저장` : '저장')}
                    </button>
                  )}
                </div>

                {/* 여러 스텝인 경우 탭 UI */}
                {generatedDocs.length > 1 && (
                  <div className="flex gap-1 mt-3 overflow-x-auto pb-2">
                    {generatedDocs.map((doc, idx) => (
                      <button
                        key={idx}
                        onClick={() => setGeneratedDoc(doc)}
                        className={`px-3 py-1.5 text-xs font-medium rounded-lg whitespace-nowrap transition-colors ${
                          generatedDoc === doc
                            ? 'bg-indigo-600 text-white'
                            : 'bg-white text-slate-600 hover:bg-slate-100 border border-slate-200'
                        }`}
                      >
                        Step {doc.step}
                        {doc.estimatedMinutes && (
                          <span className="ml-1 opacity-70">({doc.estimatedMinutes}분)</span>
                        )}
                      </button>
                    ))}
                  </div>
                )}
              </div>

              <div className="mt-4">
                {generatedDoc ? (
                  <div>
                    <div className="flex items-center gap-2 mb-4">
                      <h1 className="text-xl font-bold">{generatedDoc.title}</h1>
                      {generatedDoc.ai_processed === false && (
                        <span className="text-xs bg-amber-100 text-amber-700 px-2 py-1 rounded-full flex items-center gap-1">
                          ⚠️ AI 미처리
                        </span>
                      )}
                      {generatedDoc.estimatedMinutes && (
                        <span className="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full flex items-center gap-1">
                          <Icon name="clock" className="w-3 h-3" />
                          약 {generatedDoc.estimatedMinutes}분
                        </span>
                      )}
                    </div>
                    {/* AI 미처리 알림 배너 */}
                    {generatedDoc.ai_processed === false && (
                      <div className="my-4 p-4 bg-amber-50 border border-amber-200 rounded-lg">
                        <div className="flex items-start gap-3">
                          <span className="text-amber-500 text-lg">⚠️</span>
                          <div>
                            <p className="text-sm font-medium text-amber-800">AI 분석 실패</p>
                            <p className="text-xs text-amber-700 mt-1">
                              {generatedDoc.ai_error || '알 수 없는 오류'}로 인해 퀴즈가 생성되지 않았습니다.
                            </p>
                            <p className="text-xs text-amber-600 mt-1">
                              원문은 정상적으로 저장됩니다. 추후 AI 복구 시 재생성 가능합니다.
                            </p>
                          </div>
                        </div>
                      </div>
                    )}
                    {generatedDoc.totalSteps > 1 && (
                      <p className="text-xs text-slate-500 mb-3">
                        📚 전체 {generatedDoc.totalSteps}개 스텝 중 {generatedDoc.stepIndex}번째
                      </p>
                    )}

                    {/* URL/PDF 원문 보기 */}
                    {generatedDoc.source_type === 'url' && generatedDoc.source_url && (
                      <div className="my-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                        <div className="flex items-center gap-3">
                          <Icon name="globe" className="w-6 h-6 text-blue-600" />
                          <div className="flex-1">
                            <p className="text-sm font-medium text-blue-800">URL 원문 자료</p>
                            <p className="text-xs text-blue-600 truncate">{generatedDoc.source_url}</p>
                          </div>
                          <button
                            onClick={() => window.open(generatedDoc.source_url, '_blank')}
                            className="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition"
                          >
                            원문 보기 ↗
                          </button>
                        </div>
                      </div>
                    )}

                    {generatedDoc.source_type === 'pdf' && generatedDoc.source_file && (
                      <div className="my-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                        <div className="flex items-center gap-3">
                          <Icon name="file" className="w-6 h-6 text-red-600" />
                          <div className="flex-1">
                            <p className="text-sm font-medium text-red-800">PDF 원문 자료</p>
                            <p className="text-xs text-red-600 truncate">R2 저장됨</p>
                          </div>
                          <button
                            onClick={() => window.open(`https://mozilla.github.io/pdf.js/web/viewer.html?file=${encodeURIComponent(generatedDoc.source_file)}`, '_blank')}
                            className="px-4 py-2 bg-red-600 text-white rounded-lg text-sm font-medium hover:bg-red-700 transition"
                          >
                            PDF 보기 ↗
                          </button>
                        </div>
                      </div>
                    )}

                    {/* 기존 섹션 기반 콘텐츠 (manual 타입) */}
                    {generatedDoc.sections?.length > 0 && generatedDoc.sections.map((s, i) => (
                      <div key={i} className="my-4 bg-white p-4 rounded shadow-sm">
                        <h3 className="font-bold text-indigo-700">{s.title}</h3>
                        <p className="text-sm text-slate-600 whitespace-pre-line mt-2">{s.content}</p>
                      </div>
                    ))}
                    <div className="flex items-center gap-3 mt-4">
                      <p className="text-sm text-slate-500">퀴즈 {generatedDoc.quiz?.length || 0}문제 생성됨</p>
                      {generatedDoc.quiz?.length > 0 && (
                        <button
                          onClick={() => setShowQuizPreview(true)}
                          className="text-xs bg-indigo-100 text-indigo-700 px-3 py-1 rounded-full hover:bg-indigo-200 transition"
                        >
                          퀴즈 미리보기
                        </button>
                      )}
                    </div>
                  </div>
                ) : (
                  <div className="flex justify-center items-center h-64 text-slate-400">내용을 입력해주세요.</div>
                )}
              </div>
            </div>
          )}

          {/* 퀴즈 미리보기/수정 모달 */}
          {showQuizPreview && (generatedDoc?.quiz || editingDoc?.quiz) && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white rounded-2xl shadow-2xl max-w-3xl w-full max-h-[85vh] overflow-hidden">
                <div className="p-4 border-b border-slate-200 flex justify-between items-center">
                  <div className="flex items-center gap-3">
                    <h3 className="text-lg font-bold text-slate-800">
                      퀴즈 {quizEditMode ? '수정' : '미리보기'} ({(generatedDoc?.quiz || editingDoc?.quiz).length}문제)
                    </h3>
                    <button
                      onClick={() => setQuizEditMode(!quizEditMode)}
                      className={`px-3 py-1 text-xs font-medium rounded-full transition ${quizEditMode ? 'bg-green-100 text-green-700' : 'bg-indigo-100 text-indigo-700 hover:bg-indigo-200'}`}
                    >
                      {quizEditMode ? '✓ 수정 모드' : '수정하기'}
                    </button>
                  </div>
                  <button
                    onClick={() => { setShowQuizPreview(false); setQuizEditMode(false); }}
                    className="text-slate-400 hover:text-slate-600 text-2xl leading-none"
                  >&times;</button>
                </div>
                <div className="p-4 overflow-y-auto max-h-[calc(85vh-120px)]">
                  {(generatedDoc?.quiz || editingDoc?.quiz).map((q, idx) => (
                    <div key={idx} className="mb-4 p-4 bg-slate-50 rounded-lg">
                      <div className="flex items-start gap-2">
                        <span className="bg-indigo-600 text-white text-xs font-bold px-2 py-1 rounded">{idx + 1}</span>
                        {quizEditMode ? (
                          <input
                            type="text"
                            value={q.question}
                            onChange={(e) => handleQuizQuestionChange(idx, e.target.value)}
                            className="flex-1 px-2 py-1 border border-slate-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
                          />
                        ) : (
                          <p className="font-medium text-slate-800 flex-1">{q.question}</p>
                        )}
                        {quizEditMode && (
                          <button
                            onClick={() => handleQuizDelete(idx)}
                            className="text-red-500 hover:text-red-700 text-sm px-2"
                            title="삭제"
                          >✕</button>
                        )}
                      </div>
                      <div className="mt-3 space-y-2 ml-7">
                        {q.options?.map((opt, optIdx) => (
                          <div key={optIdx} className={`p-2 rounded text-sm flex items-center gap-2 ${(q.answer === opt || q.correct === optIdx) ? 'bg-green-100 text-green-800 font-medium border border-green-300' : 'bg-white border border-slate-200'}`}>
                            {quizEditMode && (
                              <input
                                type="radio"
                                name={`quiz-${idx}-correct`}
                                checked={q.correct === optIdx || q.answer === opt}
                                onChange={() => handleQuizCorrectChange(idx, optIdx)}
                                className="w-4 h-4 text-green-600"
                                title="정답으로 설정"
                              />
                            )}
                            {quizEditMode ? (
                              <input
                                type="text"
                                value={opt}
                                onChange={(e) => handleQuizOptionChange(idx, optIdx, e.target.value)}
                                className="flex-1 px-2 py-1 border border-slate-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
                              />
                            ) : (
                              <span className="flex-1">{opt}</span>
                            )}
                            {!quizEditMode && (q.answer === opt || q.correct === optIdx) && <span>✓</span>}
                          </div>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
                <div className="p-4 border-t border-slate-200 flex justify-between">
                  <span className="text-xs text-slate-500">
                    {quizEditMode ? '라디오 버튼으로 정답 선택' : '녹색 = 정답'}
                  </span>
                  <button
                    onClick={() => { setShowQuizPreview(false); setQuizEditMode(false); }}
                    className="px-4 py-2 bg-slate-100 text-slate-700 rounded-lg hover:bg-slate-200"
                  >닫기</button>
                </div>
              </div>
            </div>
          )}

          {/* 내가 만든 자료 목록 */}
          {myDocs.length > 0 && (
            <div className="mt-8">
              <h3 className="text-lg font-bold text-slate-800 mb-4">내가 만든 자료 ({myDocs.length})</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {myDocs.map(doc => (
                  <div key={doc.id} className="bg-white p-4 rounded-xl shadow border flex justify-between items-start">
                    <div className="flex-1">
                      <span className="text-xs font-bold bg-indigo-100 text-indigo-700 px-2 py-1 rounded">{doc.team} - Step {doc.step}</span>
                      <h4 className="font-bold mt-2">{doc.title}</h4>
                      {doc.updatedAt && (
                        <p className="text-xs text-slate-400 mt-1">수정됨: {new Date(doc.updatedAt).toLocaleDateString()}</p>
                      )}
                    </div>
                    <div className="flex gap-2 ml-2">
                      <button
                        onClick={() => handleEditDoc(doc)}
                        className="text-indigo-500 hover:text-indigo-700 p-1"
                        title="편집"
                      >
                        <Icon name="edit" className="w-4 h-4" />
                      </button>
                      <button
                        onClick={() => handleDeleteDoc(doc.id)}
                        className="text-red-500 hover:text-red-700 p-1"
                        title="삭제"
                      >
                        <Icon name="trash" className="w-4 h-4" />
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      );

      // 멘티 문서 새로고침 함수
      const refreshPublicDocs = async () => {
        const allDocs = await dbGetAll("ojt_docs");
        allDocs.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
        setPublicDocs(allDocs);
      };

      // 멘티 리스트 계산값 (useMemo로 최적화)
      const availableTeams = useMemo(() =>
        Array.from(new Set(publicDocs.map(doc => doc.team).filter(Boolean))),
        [publicDocs]
      );
      const teamDocs = useMemo(() =>
        selectedTeam ? publicDocs.filter(doc => doc.team === selectedTeam).sort((a, b) => (a.step || 0) - (b.step || 0)) : [],
        [publicDocs, selectedTeam]
      );

      // 멘티 리스트 JSX
      const menteeListContent = !selectedTeam ? (
        <div className="max-w-4xl mx-auto p-6">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold text-slate-800">학습할 팀을 선택하세요</h2>
            <button onClick={refreshPublicDocs} className="text-slate-500 hover:text-slate-700">
              <Icon name="refresh" className="w-5 h-5" />
            </button>
          </div>
          {availableTeams.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              {availableTeams.map(team => (
                <button key={team} onClick={() => setSelectedTeam(team)} className="bg-white p-6 rounded-xl shadow hover:shadow-lg border text-left transition-shadow">
                  <h3 className="font-bold text-lg text-slate-800">{team}</h3>
                  <p className="text-sm text-slate-500 mt-1">{publicDocs.filter(d => d.team === team).length}개 과정</p>
                </button>
              ))}
            </div>
          ) : (
            <div className="text-center py-16 text-slate-500">
              <Icon name="book" className="w-16 h-16 mx-auto mb-4 text-slate-300" />
              <p>아직 등록된 교육 자료가 없습니다.</p>
              <p className="text-sm mt-2">멘토가 자료를 등록하면 여기에 표시됩니다.</p>
            </div>
          )}
        </div>
      ) : (
        <div className="max-w-4xl mx-auto p-6">
          <button onClick={() => setSelectedTeam(null)} className="mb-4 text-slate-500 hover:text-slate-700">&larr; 뒤로가기</button>
          <h2 className="text-2xl font-bold mb-6">{selectedTeam} 로드맵</h2>
          <div className="space-y-4">
            {teamDocs.map((doc) => (
              <div key={doc.id} className="bg-white p-6 rounded-xl shadow border flex justify-between items-center">
                <div>
                  <span className="text-xs font-bold bg-indigo-100 text-indigo-700 px-2 py-1 rounded">Step {doc.step}</span>
                  <h3 className="font-bold text-lg mt-2">{doc.title}</h3>
                  <p className="text-xs text-slate-400 mt-1">작성자: {doc.author}</p>
                </div>
                <button onClick={() => handleSelectDoc(doc)} className="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700 transition-colors">학습하기</button>
              </div>
            ))}
          </div>
        </div>
      );

      // 멘티 학습 JSX
      const menteeStudyContent = selectedDoc ? (
        <div className="max-w-4xl mx-auto p-6">
          <button onClick={() => { setViewState('mentee_list'); setSelectedDoc(null); }} className="mb-4 text-slate-500 hover:text-slate-700">&larr; 목록으로</button>

          {!quizMode ? (
            <div className="bg-white p-8 rounded-xl shadow border">
              <div className="flex justify-between items-start mb-6">
                <div>
                  <span className="text-xs font-bold bg-indigo-100 text-indigo-700 px-2 py-1 rounded">{selectedDoc.team} - Step {selectedDoc.step}</span>
                  <h1 className="text-2xl font-bold mt-2">{selectedDoc.title}</h1>
                  <p className="text-sm text-slate-400 mt-1">작성자: {selectedDoc.author}</p>
                </div>
              </div>

              {/* URL 원문 보기 */}
              {selectedDoc.source_type === 'url' && selectedDoc.source_url && (
                <div className="mb-6 p-6 bg-blue-50 border-2 border-blue-200 rounded-xl">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-4">
                      <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center">
                        <Icon name="globe" className="w-6 h-6 text-blue-600" />
                      </div>
                      <div>
                        <p className="font-semibold text-blue-800">웹페이지 학습 자료</p>
                        <p className="text-sm text-blue-600">원문을 먼저 읽은 후 퀴즈에 도전하세요</p>
                      </div>
                    </div>
                    <button
                      onClick={() => window.open(selectedDoc.source_url, '_blank')}
                      className="px-6 py-3 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700 transition flex items-center gap-2"
                    >
                      <Icon name="eye" className="w-5 h-5" />
                      원문 보기
                    </button>
                  </div>
                </div>
              )}

              {/* PDF 원문 보기 */}
              {selectedDoc.source_type === 'pdf' && selectedDoc.source_file && (
                <div className="mb-6 p-6 bg-red-50 border-2 border-red-200 rounded-xl">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-4">
                      <div className="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center">
                        <Icon name="file" className="w-6 h-6 text-red-600" />
                      </div>
                      <div>
                        <p className="font-semibold text-red-800">PDF 학습 자료</p>
                        <p className="text-sm text-red-600">PDF를 먼저 읽은 후 퀴즈에 도전하세요</p>
                      </div>
                    </div>
                    <button
                      onClick={() => window.open(`https://mozilla.github.io/pdf.js/web/viewer.html?file=${encodeURIComponent(selectedDoc.source_file)}`, '_blank')}
                      className="px-6 py-3 bg-red-600 text-white rounded-lg font-bold hover:bg-red-700 transition flex items-center gap-2"
                    >
                      <Icon name="eye" className="w-5 h-5" />
                      PDF 보기
                    </button>
                  </div>
                </div>
              )}

              {/* AI 미처리 문서 알림 */}
              {selectedDoc.ai_processed === false && (
                <div className="mb-6 p-4 bg-amber-50 border-2 border-amber-200 rounded-xl">
                  <div className="flex items-start gap-3">
                    <span className="text-amber-500 text-xl">⚠️</span>
                    <div>
                      <p className="font-semibold text-amber-800">AI 미처리 문서</p>
                      <p className="text-sm text-amber-700 mt-1">
                        이 문서는 AI 분석 없이 원문 그대로 등록되었습니다. 퀴즈가 제공되지 않습니다.
                      </p>
                      {selectedDoc.ai_error && (
                        <p className="text-xs text-amber-600 mt-2">사유: {selectedDoc.ai_error}</p>
                      )}
                    </div>
                  </div>
                </div>
              )}

              {/* 기존 섹션 기반 콘텐츠 (manual 타입) */}
              {selectedDoc.sections?.length > 0 && selectedDoc.sections.map((s, i) => (
                <div key={i} className="mb-6">
                  <h3 className="font-bold text-indigo-700 mb-2">{s.title}</h3>
                  <p className="whitespace-pre-line text-slate-700">{s.content}</p>
                </div>
              ))}

              {/* 퀴즈 버튼 - 퀴즈가 있을 때만 표시 */}
              {selectedDoc.quiz && selectedDoc.quiz.length >= CONFIG.QUIZ_QUESTIONS_PER_TEST ? (
                <button onClick={startQuizSession} className="w-full py-4 bg-indigo-600 text-white rounded-lg font-bold mt-8 hover:bg-indigo-700 transition-colors">
                  퀴즈 도전 ({selectedDoc.quiz.length}문제 중 4문제 출제)
                </button>
              ) : (
                <div className="w-full py-4 bg-slate-100 text-slate-500 rounded-lg font-bold mt-8 text-center">
                  {selectedDoc.ai_processed === false
                    ? '퀴즈 없음 (AI 미처리 문서)'
                    : `퀴즈 부족 (${selectedDoc.quiz?.length || 0}문제 - 최소 ${CONFIG.QUIZ_QUESTIONS_PER_TEST}문제 필요)`}
                </div>
              )}
            </div>
          ) : (
            <div className="bg-white p-8 rounded-xl shadow border">
              {!quizSubmitted ? (
                <div>
                  <div className="flex justify-between mb-4">
                    <span className="font-bold text-indigo-600">Q{currentQuizIndex + 1} / 4</span>
                    <button onClick={() => setQuizMode(false)} className="text-slate-400 hover:text-slate-600"><Icon name="x" /></button>
                  </div>
                  <h3 className="text-xl font-bold mb-6">{activeQuizSet[currentQuizIndex]?.question}</h3>
                  <div className="space-y-2">
                    {activeQuizSet[currentQuizIndex]?.options?.map((opt, i) => (
                      <button
                        key={i}
                        onClick={() => handleAnswerSelect(currentQuizIndex, i)}
                        className={`w-full p-4 border rounded text-left transition-colors ${selectedAnswers[currentQuizIndex] === i ? 'bg-indigo-50 border-indigo-600' : 'hover:bg-slate-50'}`}
                      >
                        {opt}
                      </button>
                    ))}
                  </div>
                  <div className="flex justify-between mt-6">
                    <button
                      onClick={() => setCurrentQuizIndex(prev => Math.max(0, prev - 1))}
                      disabled={currentQuizIndex === 0}
                      className="text-slate-400 disabled:opacity-50"
                    >
                      이전
                    </button>
                    {currentQuizIndex < 3 ? (
                      <button onClick={() => setCurrentQuizIndex(prev => prev + 1)} className="bg-slate-800 text-white px-4 py-2 rounded hover:bg-slate-900">다음</button>
                    ) : (
                      <button onClick={submitQuiz} className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">제출</button>
                    )}
                  </div>
                </div>
              ) : (
                <div className="text-center py-8">
                  <h2 className="text-3xl font-bold mb-2">{passed ? "통과!" : "아쉬워요"}</h2>
                  <p className="text-xl mb-2 text-slate-600">{score} / 4 문제 정답</p>
                  <p className="text-slate-500 mb-6">{passed ? "훌륭합니다! 다음 단계로 넘어가세요." : `${QUIZ_PASS_THRESHOLD}문제 이상 맞춰야 통과입니다.`}</p>
                  <div className="flex gap-4 justify-center">
                    {!passed && (
                      <button onClick={startQuizSession} className="bg-indigo-600 text-white px-6 py-2 rounded hover:bg-indigo-700">다시 도전</button>
                    )}
                    <button onClick={() => { setViewState('mentee_list'); setSelectedDoc(null); setSelectedTeam(null); }} className="bg-slate-600 text-white px-6 py-2 rounded hover:bg-slate-700">목록으로</button>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      ) : null;

      // =========================================
      // Main Render
      // =========================================

      // 로딩 중 (초기 로드 또는 인증 처리 중)
      if (isLoadingAuth || viewState === 'loading') {
        return (
          <div className="flex h-screen items-center justify-center">
            <Icon name="refresh" className="w-8 h-8 animate-spin text-indigo-600" />
          </div>
        );
      }

      // 로그인 페이지
      if (viewState === 'login') {
        return <LoginPage />;
      }

      // 메인 앱 (로그인 후)
      return (
        <div className="min-h-screen bg-slate-50 font-sans text-slate-900">
          <Header />
          {/* Admin 임시 모드 경고 배너 */}
          {user?.role === 'admin' && sessionMode && (
            <div className="bg-amber-100 border-b-2 border-amber-400 px-4 py-2 flex items-center justify-between">
              <div className="flex items-center gap-2 text-amber-800">
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                </svg>
                <span className="text-sm font-medium">
                  <strong>{sessionMode.toUpperCase()}</strong> 모드로 작업 중입니다 (임시)
                </span>
              </div>
              <button
                onClick={() => handleModeSwitch(null)}
                className="text-amber-700 hover:text-amber-900 text-sm font-semibold px-3 py-1 rounded hover:bg-amber-200 transition"
              >
                Admin으로 돌아가기
              </button>
            </div>
          )}
          <main>
            {viewState === 'role_select' && <RoleSelectionPage />}
            {viewState === 'admin_dashboard' && <AdminDashboard />}
            {viewState === 'mentor_dashboard' && mentorDashboardContent}
            {viewState === 'mentee_list' && menteeListContent}
            {viewState === 'mentee_study' && menteeStudyContent}
          </main>
          {/* Toast Container */}
          {typeof window.reactHotToast !== 'undefined' && window.reactHotToast.Toaster && (
            <window.reactHotToast.Toaster
              position="top-center"
              toastOptions={{
                style: { background: '#333', color: '#fff', maxWidth: '500px' },
                success: { duration: 3000, iconTheme: { primary: '#10b981', secondary: '#fff' } },
                error: { duration: 5000, iconTheme: { primary: '#ef4444', secondary: '#fff' } }
              }}
            />
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
